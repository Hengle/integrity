; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Network\Net\Src\sock.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??0CSock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCSock@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CSock@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CSock@@UAEHGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CSock@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CSock@@UAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Detach@CSock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHostAddr@CSock@@UAEJPAXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KU_Friend@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKU_Friend@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CSock@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??0CSock@@QAE@XZ				; CSock::CSock
PUBLIC	?Create@CSock@@UAEHGH@Z				; CSock::Create
PUBLIC	?Attach@CSock@@UAEXI@Z				; CSock::Attach
PUBLIC	?Detach@CSock@@UAEXXZ				; CSock::Detach
PUBLIC	?GetHostAddr@CSock@@UAEJPAXPAK@Z		; CSock::GetHostAddr
PUBLIC	?GetPeerAddr@CSock@@UAEKK@Z			; CSock::GetPeerAddr
PUBLIC	?Get@CSock@@UAEPAV1@I@Z				; CSock::Get
PUBLIC	??_7CSock@@6B@					; CSock::`vftable'
PUBLIC	??_GCSock@@UAEPAXI@Z				; CSock::`scalar deleting destructor'
EXTRN	__purecall:NEAR
EXTRN	??_ECSock@@UAEPAXI@Z:NEAR			; CSock::`vector deleting destructor'
;	COMDAT ??_7CSock@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\sock.cpp
CONST	SEGMENT
??_7CSock@@6B@ DD FLAT:??_ECSock@@UAEPAXI@Z		; CSock::`vftable'
	DD	FLAT:?Create@CSock@@UAEHGH@Z
	DD	FLAT:?Attach@CSock@@UAEXI@Z
	DD	FLAT:?Detach@CSock@@UAEXXZ
	DD	FLAT:?GetHostAddr@CSock@@UAEJPAXPAK@Z
	DD	FLAT:?GetPeerAddr@CSock@@UAEKK@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:?Get@CSock@@UAEPAV1@I@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CSock@@QAE@XZ
_TEXT	SEGMENT
??0CSock@@QAE@XZ PROC NEAR				; CSock::CSock, COMDAT
; _this$ = ecx

; 5    : {

  00000	8b c1		 mov	 eax, ecx

; 6    : 	m_hSocket	= INVALID_SOCKET;

  00002	83 c9 ff	 or	 ecx, -1
  00005	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:??_7CSock@@6B@
  0000b	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 7    : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  0000e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  00011	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 8    : }

  00014	c3		 ret	 0
??0CSock@@QAE@XZ ENDP					; CSock::CSock
_TEXT	ENDS
PUBLIC	?Clear@CSock@@QAEXXZ				; CSock::Clear
EXTRN	__imp__closesocket@4:NEAR
EXTRN	__imp__shutdown@8:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Clear@CSock@@QAEXXZ
_TEXT	SEGMENT
?Clear@CSock@@QAEXXZ PROC NEAR				; CSock::Clear, COMDAT
; _this$ = ecx

; 49   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 50   : 	CLOSE_SOCKET( m_hSocket );

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	83 cf ff	 or	 edi, -1
  0000a	3b c7		 cmp	 eax, edi
  0000c	74 16		 je	 SHORT $L186919
  0000e	6a 02		 push	 2
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00017	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001a	50		 push	 eax
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00021	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$L186919:

; 51   : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  00024	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  00027	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi

; 52   : }

  0002c	c3		 ret	 0
?Clear@CSock@@QAEXXZ ENDP				; CSock::Clear
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Attach@CSock@@UAEXI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Attach@CSock@@UAEXI@Z PROC NEAR			; CSock::Attach, COMDAT
; _this$ = ecx

; 55   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 56   : 	Clear();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 1a		 je	 SHORT $L186924
  0000b	6a 02		 push	 2
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0001e	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L186924:

; 57   : 	m_hSocket	= hSocket;

  00025	8b 4c 24 08	 mov	 ecx, DWORD PTR _hSocket$[esp]
  00029	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00030	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  00037	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  0003a	5e		 pop	 esi

; 58   : }

  0003b	c2 04 00	 ret	 4
?Attach@CSock@@UAEXI@Z ENDP				; CSock::Attach
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Detach@CSock@@UAEXXZ
_TEXT	SEGMENT
?Detach@CSock@@UAEXXZ PROC NEAR				; CSock::Detach, COMDAT
; _this$ = ecx

; 62   : 	m_hSocket	= INVALID_SOCKET;

  00000	83 c8 ff	 or	 eax, -1
  00003	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 63   : 	m_dpid	= m_dpidpeer	= DPID_UNKNOWN;

  00006	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00009	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 64   : }

  0000c	c3		 ret	 0
?Detach@CSock@@UAEXXZ ENDP				; CSock::Detach
_TEXT	ENDS
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
EXTRN	_sprintf:NEAR
EXTRN	__imp__gethostbyname@4:NEAR
EXTRN	__imp__gethostname@8:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetHostAddr@CSock@@UAEJPAXPAK@Z
_TEXT	SEGMENT
_sin$ = -276						; size = 16
_name$ = -260						; size = 255
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAddr$ = 8						; size = 4
_lpdwSize$ = 12						; size = 4
?GetHostAddr@CSock@@UAEJPAXPAK@Z PROC NEAR		; CSock::GetHostAddr, COMDAT
; _this$ = ecx

; 67   : {

  00000	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c4		 xor	 eax, esp
  0000d	56		 push	 esi
  0000e	8b b4 24 1c 01
	00 00		 mov	 esi, DWORD PTR _lpAddr$[esp+276]
  00015	89 84 24 14 01
	00 00		 mov	 DWORD PTR __$ArrayPad$[esp+280], eax

; 68   : 	ASSERT( lpAddr );
; 69   : 
; 70   : 	char name[255];
; 71   : 	LPHOSTENT lphost;
; 72   : 
; 73   : 	gethostname( name, sizeof(char)*255 );

  0001c	68 ff 00 00 00	 push	 255			; 000000ffH
  00021	8d 44 24 18	 lea	 eax, DWORD PTR _name$[esp+284]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostname@8

; 74   : 
; 75   : 	SOCKADDR_IN sin;
; 76   : 	ZeroMemory( &sin, sizeof(SOCKADDR_IN) );
; 77   : 
; 78   : 	sin.sin_family	= AF_INET;
; 79   : 	lphost	= gethostbyname( name );

  0002c	8d 4c 24 14	 lea	 ecx, DWORD PTR _name$[esp+280]
  00030	51		 push	 ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 80   : 
; 81   : 	if( lphost != NULL )

  00037	85 c0		 test	 eax, eax
  00039	74 4a		 je	 SHORT $L186753

; 82   : 		sin.sin_addr.s_addr		= ( (LPIN_ADDR)lphost->h_addr )->s_addr;

  0003b	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  0003e	8b 02		 mov	 eax, DWORD PTR [edx]
  00040	8b 00		 mov	 eax, DWORD PTR [eax]

; 83   : 	else
; 84   : 		return DPERR_INVALIDPARAM;
; 85   : 
; 86   : 	sprintf( (char *)lpAddr, "%d.%d.%d.%d", sin.sin_addr.s_net
; 87   : 																	, sin.sin_addr.s_host
; 88   : 																	, sin.sin_addr.s_lh
; 89   : 																	, sin.sin_addr.s_impno );

  00042	8b d0		 mov	 edx, eax
  00044	c1 ea 10	 shr	 edx, 16			; 00000010H
  00047	8b c8		 mov	 ecx, eax
  00049	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0004c	51		 push	 ecx
  0004d	0f b6 d2	 movzx	 edx, dl
  00050	52		 push	 edx
  00051	0f b6 cc	 movzx	 ecx, ah
  00054	51		 push	 ecx
  00055	0f b6 d0	 movzx	 edx, al
  00058	52		 push	 edx
  00059	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  0005e	56		 push	 esi
  0005f	89 44 24 20	 mov	 DWORD PTR _sin$[esp+308], eax
  00063	e8 00 00 00 00	 call	 _sprintf
  00068	83 c4 18	 add	 esp, 24			; 00000018H

; 90   : 	return DP_OK;

  0006b	33 c0		 xor	 eax, eax
  0006d	5e		 pop	 esi

; 91   : }

  0006e	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+276]
  00075	33 cc		 xor	 ecx, esp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00082	c2 08 00	 ret	 8
$L186753:
  00085	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR __$ArrayPad$[esp+280]
  0008c	5e		 pop	 esi
  0008d	33 cc		 xor	 ecx, esp
  0008f	b8 57 00 07 80	 mov	 eax, -2147024809	; 80070057H
  00094	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00099	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  0009f	c2 08 00	 ret	 8
?GetHostAddr@CSock@@UAEJPAXPAK@Z ENDP			; CSock::GetHostAddr
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\sock.h
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT
_dpid$ = 8						; size = 4
?GetPeerAddr@CSock@@UAEKK@Z PROC NEAR			; CSock::GetPeerAddr, COMDAT
; _this$ = ecx

; 37   : 	virtual	DWORD	GetPeerAddr( DPID dpid ) { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetPeerAddr@CSock@@UAEKK@Z ENDP			; CSock::GetPeerAddr
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Get@CSock@@UAEPAV1@I@Z PROC NEAR			; CSock::Get, COMDAT
; _this$ = ecx

; 51   : inline CSock* CSock::Get( SOCKET hSocket )	{	return( m_hSocket == hSocket ? this : NULL );	}

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	8b 74 24 08	 mov	 esi, DWORD PTR _hSocket$[esp]
  00008	33 c0		 xor	 eax, eax
  0000a	3b d6		 cmp	 edx, esi
  0000c	0f 95 c0	 setne	 al
  0000f	5e		 pop	 esi
  00010	48		 dec	 eax
  00011	23 c1		 and	 eax, ecx
  00013	c2 04 00	 ret	 4
?Get@CSock@@UAEPAV1@I@Z ENDP				; CSock::Get
_TEXT	ENDS
PUBLIC	??1CSock@@UAE@XZ				; CSock::~CSock
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\sock.cpp
;	COMDAT ??1CSock@@UAE@XZ
_TEXT	SEGMENT
??1CSock@@UAE@XZ PROC NEAR				; CSock::~CSock, COMDAT
; _this$ = ecx

; 11   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 12   : 	Clear();

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	57		 push	 edi
  00007	83 cf ff	 or	 edi, -1
  0000a	3b c7		 cmp	 eax, edi
  0000c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSock@@6B@
  00012	74 16		 je	 SHORT $L186945
  00014	6a 02		 push	 2
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  0001d	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00020	50		 push	 eax
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00027	89 7e 04	 mov	 DWORD PTR [esi+4], edi
$L186945:
  0002a	89 7e 0c	 mov	 DWORD PTR [esi+12], edi
  0002d	89 7e 08	 mov	 DWORD PTR [esi+8], edi
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi

; 13   : }

  00032	c3		 ret	 0
??1CSock@@UAE@XZ ENDP					; CSock::~CSock
_TEXT	ENDS
EXTRN	__imp__bind@12:NEAR
EXTRN	__imp__htonl@4:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__setsockopt@20:NEAR
EXTRN	__imp__WSASocketA@24:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Create@CSock@@UAEHGH@Z
_TEXT	SEGMENT
_lLinger$ = -28						; size = 4
_reuse$ = -24						; size = 4
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_uPort$ = 8						; size = 2
_type$ = 12						; size = 4
?Create@CSock@@UAEHGH@Z PROC NEAR			; CSock::Create, COMDAT
; _this$ = ecx

; 16   : {

  00000	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	8b f1		 mov	 esi, ecx
  0000d	89 44 24 1c	 mov	 DWORD PTR __$ArrayPad$[esp+32], eax

; 17   : 	SOCKADDR_IN sin;
; 18   : 
; 19   : 	Clear();

  00011	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00014	83 f8 ff	 cmp	 eax, -1
  00017	74 1a		 je	 SHORT $L186954
  00019	6a 02		 push	 2
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00022	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0002c	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L186954:

; 20   : 
; 21   : 	if( ( m_hSocket = WSASocket( AF_INET, type, 0, NULL, 0, WSA_FLAG_OVERLAPPED ) ) == INVALID_SOCKET )

  00033	8b 4c 24 28	 mov	 ecx, DWORD PTR _type$[esp+28]
  00037	6a 01		 push	 1
  00039	6a 00		 push	 0
  0003b	6a 00		 push	 0
  0003d	6a 00		 push	 0
  0003f	51		 push	 ecx
  00040	6a 02		 push	 2
  00042	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00049	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASocketA@24
  00056	83 f8 ff	 cmp	 eax, -1
  00059	89 46 04	 mov	 DWORD PTR [esi+4], eax
  0005c	75 14		 jne	 SHORT $L186716

; 22   : 	{
; 23   : 		TRACE( "Can't create socket with error %d\n", WSAGetLastError() );
; 24   : 		return FALSE;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 40   : 	{
; 41   : 		TRACE( "Can't bind socket with error %d\n", WSAGetLastError() );
; 42   : 		return FALSE;
; 43   : 	}
; 44   : 
; 45   : 	return TRUE;
; 46   : }

  00061	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  00065	33 cc		 xor	 ecx, esp
  00067	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0006f	c2 08 00	 ret	 8
$L186716:
  00072	57		 push	 edi

; 25   : 	}
; 26   : 
; 27   : 	int reuse	= 1;
; 28   : 	setsockopt( m_hSocket, SOL_SOCKET,SO_REUSEADDR, (char FAR*)&reuse, sizeof(int) );

  00073	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__setsockopt@20
  00079	6a 04		 push	 4
  0007b	8d 54 24 10	 lea	 edx, DWORD PTR _reuse$[esp+40]
  0007f	52		 push	 edx
  00080	6a 04		 push	 4
  00082	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00087	50		 push	 eax
  00088	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR _reuse$[esp+56], 1
  00090	ff d7		 call	 edi

; 29   : 	
; 30   : 	LINGER lLinger;
; 31   : 	lLinger.l_onoff		= 0;
; 32   : 	lLinger.l_linger	= 0;
; 33   : 	setsockopt( m_hSocket, SOL_SOCKET, SO_LINGER, (const char *)&lLinger, sizeof(LINGER) );

  00092	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00095	6a 04		 push	 4
  00097	8d 44 24 0c	 lea	 eax, DWORD PTR _lLinger$[esp+40]
  0009b	50		 push	 eax
  0009c	68 80 00 00 00	 push	 128			; 00000080H
  000a1	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000a6	51		 push	 ecx
  000a7	66 c7 44 24 1c
	00 00		 mov	 WORD PTR _lLinger$[esp+56], 0
  000ae	66 c7 44 24 1e
	00 00		 mov	 WORD PTR _lLinger$[esp+58], 0
  000b5	ff d7		 call	 edi

; 34   : 
; 35   : 	sin.sin_family	= PF_INET;
; 36   : 	sin.sin_addr.s_addr		= htonl( INADDR_ANY );

  000b7	6a 00		 push	 0
  000b9	66 c7 44 24 14
	02 00		 mov	 WORD PTR _sin$[esp+40], 2
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htonl@4

; 37   : 	sin.sin_port	= htons( uPort );

  000c6	8b 54 24 28	 mov	 edx, DWORD PTR _uPort$[esp+32]
  000ca	52		 push	 edx
  000cb	89 44 24 18	 mov	 DWORD PTR _sin$[esp+44], eax
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 38   : 
; 39   : 	if( bind( m_hSocket, (LPSOCKADDR) &sin, sizeof(sin) ) == SOCKET_ERROR )

  000d5	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000d8	66 89 44 24 12	 mov	 WORD PTR _sin$[esp+38], ax
  000dd	6a 10		 push	 16			; 00000010H
  000df	8d 44 24 14	 lea	 eax, DWORD PTR _sin$[esp+40]
  000e3	50		 push	 eax
  000e4	51		 push	 ecx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12

; 40   : 	{
; 41   : 		TRACE( "Can't bind socket with error %d\n", WSAGetLastError() );
; 42   : 		return FALSE;
; 43   : 	}
; 44   : 
; 45   : 	return TRUE;
; 46   : }

  000eb	8b 4c 24 20	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+36]
  000ef	33 d2		 xor	 edx, edx
  000f1	83 f8 ff	 cmp	 eax, -1
  000f4	0f 95 c2	 setne	 dl
  000f7	5f		 pop	 edi
  000f8	5e		 pop	 esi
  000f9	33 cc		 xor	 ecx, esp
  000fb	8b c2		 mov	 eax, edx
  000fd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00102	83 c4 1c	 add	 esp, 28			; 0000001cH
  00105	c2 08 00	 ret	 8
?Create@CSock@@UAEHGH@Z ENDP				; CSock::Create
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCSock@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCSock@@UAEPAXI@Z PROC NEAR				; CSock::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CSock@@6B@
  0000f	74 1a		 je	 SHORT $L186966
  00011	6a 02		 push	 2
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  0001a	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00024	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L186966:
  0002b	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00030	c7 46 0c ff ff
	ff ff		 mov	 DWORD PTR [esi+12], -1
  00037	c7 46 08 ff ff
	ff ff		 mov	 DWORD PTR [esi+8], -1
  0003e	74 09		 je	 SHORT $L186968
  00040	56		 push	 esi
  00041	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00046	83 c4 04	 add	 esp, 4
$L186968:
  00049	8b c6		 mov	 eax, esi
  0004b	5e		 pop	 esi
  0004c	c2 04 00	 ret	 4
??_GCSock@@UAEPAXI@Z ENDP				; CSock::`scalar deleting destructor'
_TEXT	ENDS
END
