; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Network\Net\Src\clientsock.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0GM@GGAAMOBM@?2Documents?5and?5Settings?2test?2Mes@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@ODKLMECE@CClientSocket?4Fetch?3?5ip?5?$DN?5?$CFs?0?5si@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?GetHandle@CSock@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CClientSock@@UAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCClientSock@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CClientSock@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CClientSock@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseConnection@CClientSock@@UAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shutdown@CClientSock@@UAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Connect@CClientSock@@QAEHPADG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Send@CClientSock@@UAEXPADKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Recv@CClientSock@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendRemnant@CClientSock@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fetch@CClientSock@@QAEPAVCBuffer@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBuffer@CClientSock@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CClientSock@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetHandle@CSock@@QAEIXZ			; CSock::GetHandle
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\sock.h
;	COMDAT ?GetHandle@CSock@@QAEIXZ
_TEXT	SEGMENT
?GetHandle@CSock@@QAEIXZ PROC NEAR			; CSock::GetHandle, COMDAT
; _this$ = ecx

; 50   : inline SOCKET CSock::GetHandle( void )	{	return m_hSocket;	}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetHandle@CSock@@QAEIXZ ENDP				; CSock::GetHandle
_TEXT	ENDS
PUBLIC	?GetHeaderLength@CBuffer@@QAEKXZ		; CBuffer::GetHeaderLength
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT
?GetHeaderLength@CBuffer@@QAEKXZ PROC NEAR		; CBuffer::GetHeaderLength, COMDAT
; _this$ = ecx

; 66   : 		return m_dwHeaderSize;

  00000	8b 81 24 20 00
	00		 mov	 eax, DWORD PTR [ecx+8228]

; 67   : 	}

  00006	c3		 ret	 0
?GetHeaderLength@CBuffer@@QAEKXZ ENDP			; CBuffer::GetHeaderLength
_TEXT	ENDS
PUBLIC	?GetSize@CBuffer@@QAEHXZ			; CBuffer::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CBuffer@@QAEHXZ PROC NEAR			; CBuffer::GetSize, COMDAT
; _this$ = ecx

; 99   : 	return (int)( m_lpBufMax - m_lpBufStart );	

  00000	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  00006	2b 81 0c 20 00
	00		 sub	 eax, DWORD PTR [ecx+8204]

; 100  : }

  0000c	c3		 ret	 0
?GetSize@CBuffer@@QAEHXZ ENDP				; CBuffer::GetSize
_TEXT	ENDS
PUBLIC	?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetWritableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetWritableBuffer, COMDAT
; _this$ = ecx

; 104  : 	*pnBufSize	= (int)( m_lpBufMax - m_pTail );	

  00000	8b 91 18 20 00
	00		 mov	 edx, DWORD PTR [ecx+8216]
  00006	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 105  : 	return m_pTail;	

  00014	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]

; 106  : }

  0001a	c2 04 00	 ret	 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetWritableBuffer
_TEXT	ENDS
PUBLIC	?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetReadableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetReadableBuffer, COMDAT
; _this$ = ecx

; 115  : 	*pnBufSize	= (int)( m_pTail - m_pHead );	

  00000	8b 91 14 20 00
	00		 mov	 edx, DWORD PTR [ecx+8212]
  00006	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 116  : 	return m_pHead;	

  00014	8b 81 14 20 00
	00		 mov	 eax, DWORD PTR [ecx+8212]

; 117  : }

  0001a	c2 04 00	 ret	 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetReadableBuffer
_TEXT	ENDS
PUBLIC	?IsEmpty@CBufferQueue@@QAEHXZ			; CBufferQueue::IsEmpty
; Function compile flags: /Ogty
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CBufferQueue@@QAEHXZ PROC NEAR			; CBufferQueue::IsEmpty, COMDAT
; _this$ = ecx

; 222  : 	{	return( m_uCount == 0 );	}

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CBufferQueue@@QAEHXZ ENDP			; CBufferQueue::IsEmpty
_TEXT	ENDS
PUBLIC	?Close@CClientSock@@UAEXXZ			; CClientSock::Close
EXTRN	__imp__closesocket@4:NEAR
EXTRN	__imp__shutdown@8:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
;	COMDAT ?Close@CClientSock@@UAEXXZ
_TEXT	SEGMENT
?Close@CClientSock@@UAEXXZ PROC NEAR			; CClientSock::Close, COMDAT
; _this$ = ecx

; 100  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 101  : 	CLOSE_SOCKET( m_hSocket );

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	74 1a		 je	 SHORT $L227551
  0000b	6a 02		 push	 2
  0000d	50		 push	 eax
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00014	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00017	50		 push	 eax
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0001e	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L227551:

; 102  : 	SAFE_DELETE( m_pRecvBuffer );

  00025	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00028	85 c9		 test	 ecx, ecx
  0002a	74 0d		 je	 SHORT $L227553
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	6a 01		 push	 1
  00030	ff 12		 call	 DWORD PTR [edx]
  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$L227553:
  00039	5e		 pop	 esi

; 103  : }

  0003a	c3		 ret	 0
?Close@CClientSock@@UAEXXZ ENDP				; CClientSock::Close
_TEXT	ENDS
PUBLIC	?CloseConnection@CClientSock@@UAEHI@Z		; CClientSock::CloseConnection
; Function compile flags: /Ogty
;	COMDAT ?CloseConnection@CClientSock@@UAEHI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?CloseConnection@CClientSock@@UAEHI@Z PROC NEAR		; CClientSock::CloseConnection, COMDAT
; _this$ = ecx

; 107  : 	ASSERT( hSocket == m_hSocket );
; 108  : 	Close();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 50 1c	 call	 DWORD PTR [eax+28]

; 109  : 	return( TRUE );

  00005	b8 01 00 00 00	 mov	 eax, 1

; 110  : }

  0000a	c2 04 00	 ret	 4
?CloseConnection@CClientSock@@UAEHI@Z ENDP		; CClientSock::CloseConnection
_TEXT	ENDS
PUBLIC	?Shutdown@CClientSock@@UAEHI@Z			; CClientSock::Shutdown
; Function compile flags: /Ogty
;	COMDAT ?Shutdown@CClientSock@@UAEHI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Shutdown@CClientSock@@UAEHI@Z PROC NEAR		; CClientSock::Shutdown, COMDAT
; _this$ = ecx

; 114  : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 115  : }

  00002	c2 04 00	 ret	 4
?Shutdown@CClientSock@@UAEHI@Z ENDP			; CClientSock::Shutdown
_TEXT	ENDS
PUBLIC	?Connect@CClientSock@@QAEHPADG@Z		; CClientSock::Connect
EXTRN	__imp__connect@12:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__inet_addr@4:NEAR
EXTRN	__imp__gethostbyname@4:NEAR
EXTRN	__imp__WSASetLastError@4:NEAR
EXTRN	__imp__WSAGetLastError@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Connect@CClientSock@@QAEHPADG@Z
_TEXT	SEGMENT
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAddr$ = 8						; size = 4
_uPort$ = 12						; size = 2
?Connect@CClientSock@@QAEHPADG@Z PROC NEAR		; CClientSock::Connect, COMDAT
; _this$ = ecx

; 125  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	8b 74 24 1c	 mov	 esi, DWORD PTR _lpAddr$[esp+20]
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax

; 126  : 	if( m_hSocket == INVALID_SOCKET )

  00016	83 7f 04 ff	 cmp	 DWORD PTR [edi+4], -1

; 127  : 	{
; 128  : 		TRACE( "Creation needed\n" );
; 129  : 		return FALSE;

  0001a	0f 84 93 00 00
	00		 je	 $L228953

; 130  : 	}
; 131  : 
; 132  : 	SOCKADDR_IN sin;
; 133  : 	memset( &sin, 0, sizeof(sin) );

  00020	33 c0		 xor	 eax, eax
  00022	89 44 24 08	 mov	 DWORD PTR _sin$[esp+28], eax
  00026	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
  0002a	89 44 24 10	 mov	 DWORD PTR _sin$[esp+36], eax

; 134  : 	sin.sin_family		= AF_INET;
; 135  : 	sin.sin_addr.s_addr	= inet_addr( lpAddr );

  0002e	56		 push	 esi
  0002f	89 44 24 18	 mov	 DWORD PTR _sin$[esp+44], eax
  00033	66 c7 44 24 0c
	02 00		 mov	 WORD PTR _sin$[esp+32], 2
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4

; 136  : 	if( sin.sin_addr.s_addr == INADDR_NONE )

  00040	83 f8 ff	 cmp	 eax, -1
  00043	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
  00047	75 16		 jne	 SHORT $L227578

; 137  : 	{
; 138  : 		LPHOSTENT lphost;
; 139  : 		lphost	= gethostbyname( lpAddr );

  00049	56		 push	 esi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 140  : 		if( lphost )

  00050	85 c0		 test	 eax, eax
  00052	74 54		 je	 SHORT $L227576

; 141  : 			sin.sin_addr.s_addr		= ((LPIN_ADDR)lphost->h_addr)->s_addr;

  00054	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
$L227578:

; 149  : 		}
; 150  : 	}
; 151  : 	sin.sin_port = htons( uPort );

  0005f	8b 4c 24 24	 mov	 ecx, DWORD PTR _uPort$[esp+24]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 152  : 
; 153  : 	if( connect( m_hSocket, (LPSOCKADDR) &sin, sizeof(sin) ) == SOCKET_ERROR )

  0006a	6a 10		 push	 16			; 00000010H
  0006c	8d 54 24 0c	 lea	 edx, DWORD PTR _sin$[esp+32]
  00070	66 89 44 24 0e	 mov	 WORD PTR _sin$[esp+34], ax
  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	52		 push	 edx
  00079	50		 push	 eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__connect@12
  00080	83 f8 ff	 cmp	 eax, -1
  00083	75 43		 jne	 SHORT $L227580

; 154  : 	{
; 155  : 		int	err;
; 156  : 		if( ( err = WSAGetLastError() ) == WSAEWOULDBLOCK )		// ??

  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0008b	2d 33 27 00 00	 sub	 eax, 10035		; 00002733H
  00090	f7 d8		 neg	 eax
  00092	1b c0		 sbb	 eax, eax
  00094	5f		 pop	 edi
  00095	40		 inc	 eax
  00096	5e		 pop	 esi

; 157  : 			return TRUE;
; 158  : 		#ifdef __INFO_SOCKLIB0516
; 159  : 			m_dwDbgInfo = err;
; 160  : 		#endif
; 161  : 
; 162  : 		TRACE( "Can't connect with error %d: ip(%s)n", err, lpAddr );
; 163  : 		return FALSE;
; 164  : 	}
; 165  : 	return TRUE;
; 166  : }

  00097	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  0009b	33 cc		 xor	 ecx, esp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	c2 08 00	 ret	 8
$L227576:

; 142  : 		else
; 143  : 		{
; 144  : 			#ifdef __INFO_SOCKLIB0516
; 145  : 				m_dwDbgInfo = WSAEINVAL;
; 146  : 			#endif
; 147  : 			WSASetLastError( WSAEINVAL );

  000a8	68 26 27 00 00	 push	 10022			; 00002726H
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASetLastError@4
$L228953:
  000b3	5f		 pop	 edi

; 148  : 			return FALSE;

  000b4	33 c0		 xor	 eax, eax
  000b6	5e		 pop	 esi

; 157  : 			return TRUE;
; 158  : 		#ifdef __INFO_SOCKLIB0516
; 159  : 			m_dwDbgInfo = err;
; 160  : 		#endif
; 161  : 
; 162  : 		TRACE( "Can't connect with error %d: ip(%s)n", err, lpAddr );
; 163  : 		return FALSE;
; 164  : 	}
; 165  : 	return TRUE;
; 166  : }

  000b7	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  000bb	33 cc		 xor	 ecx, esp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	83 c4 14	 add	 esp, 20			; 00000014H
  000c5	c2 08 00	 ret	 8
$L227580:
  000c8	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	33 cc		 xor	 ecx, esp
  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	83 c4 14	 add	 esp, 20			; 00000014H
  000dd	c2 08 00	 ret	 8
?Connect@CClientSock@@QAEHPADG@Z ENDP			; CClientSock::Connect
_TEXT	ENDS
PUBLIC	?Recv@CClientSock@@QAEHXZ			; CClientSock::Recv
EXTRN	__imp__WSARecv@28:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Recv@CClientSock@@QAEHXZ
_TEXT	SEGMENT
_dwFlags$ = -16						; size = 4
_dwBytesRecvd$ = -12					; size = 4
_buffer$ = -8						; size = 8
?Recv@CClientSock@@QAEHXZ PROC NEAR			; CClientSock::Recv, COMDAT
; _this$ = ecx

; 204  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H

; 205  : 	ASSERT( m_hSocket != INVALID_SOCKET );
; 206  : 	DWORD dwBytesRecvd	= 0, dwFlags	= 0;
; 207  : 
; 208  : 	WSABUF buffer;
; 209  : 	buffer.buf	= (char*)m_pRecvBuffer->GetWritableBuffer( (int*)&buffer.len );

  00003	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	33 d2		 xor	 edx, edx
  0000a	89 54 24 0c	 mov	 DWORD PTR _dwBytesRecvd$[esp+24], edx
  0000e	89 54 24 08	 mov	 DWORD PTR _dwFlags$[esp+24], edx
  00012	8b b8 18 20 00
	00		 mov	 edi, DWORD PTR [eax+8216]
  00018	8b b0 10 20 00
	00		 mov	 esi, DWORD PTR [eax+8208]
  0001e	2b f7		 sub	 esi, edi
  00020	89 74 24 10	 mov	 DWORD PTR _buffer$[esp+24], esi
  00024	8b 80 18 20 00
	00		 mov	 eax, DWORD PTR [eax+8216]

; 210  : 
; 211  : 	memset( &m_ovRecv, 0, sizeof(WSAOVERLAPPED) );
; 212  : 
; 213  : 	int err;
; 214  : 	if( WSARecv( GetHandle(), &buffer, (DWORD)1, &dwBytesRecvd, &dwFlags, &m_ovRecv, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  0002a	52		 push	 edx
  0002b	89 44 24 18	 mov	 DWORD PTR _buffer$[esp+32], eax
  0002f	8d 41 14	 lea	 eax, DWORD PTR [ecx+20]
  00032	33 f6		 xor	 esi, esi
  00034	50		 push	 eax
  00035	8b f8		 mov	 edi, eax
  00037	89 37		 mov	 DWORD PTR [edi], esi
  00039	89 77 04	 mov	 DWORD PTR [edi+4], esi
  0003c	8d 54 24 10	 lea	 edx, DWORD PTR _dwFlags$[esp+32]
  00040	52		 push	 edx
  00041	89 77 08	 mov	 DWORD PTR [edi+8], esi
  00044	8d 44 24 18	 lea	 eax, DWORD PTR _dwBytesRecvd$[esp+36]
  00048	50		 push	 eax
  00049	89 77 0c	 mov	 DWORD PTR [edi+12], esi
  0004c	6a 01		 push	 1
  0004e	8d 54 24 24	 lea	 edx, DWORD PTR _buffer$[esp+44]
  00052	89 77 10	 mov	 DWORD PTR [edi+16], esi
  00055	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00058	52		 push	 edx
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
  00060	85 c0		 test	 eax, eax
  00062	5f		 pop	 edi
  00063	5e		 pop	 esi
  00064	74 0d		 je	 SHORT $L227618
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0006c	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H

; 215  : 	{
; 216  : //		TRACE( "I/o error, close socket %d, %x //REF:%d\n", GetHandle(), this, m_l-1 );
; 217  : 		return err;

  00071	75 02		 jne	 SHORT $L227608
$L227618:

; 218  : 	}
; 219  : 
; 220  : 	return 0;

  00073	33 c0		 xor	 eax, eax
$L227608:

; 221  : }

  00075	83 c4 10	 add	 esp, 16			; 00000010H
  00078	c3		 ret	 0
?Recv@CClientSock@@QAEHXZ ENDP				; CClientSock::Recv
_TEXT	ENDS
PUBLIC	?Fetch@CClientSock@@QAEPAVCBuffer@@K@Z		; CClientSock::Fetch
PUBLIC	??_C@_0GM@GGAAMOBM@?2Documents?5and?5Settings?2test?2Mes@ ; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
PUBLIC	??_C@_0CI@ODKLMECE@CClientSocket?4Fetch?3?5ip?5?$DN?5?$CFs?0?5si@ ; `string'
EXTRN	?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z:NEAR ; CBufferFactory::CreateBuffer
EXTRN	?GetInstance@CBufferFactory@@SAAAV1@XZ:NEAR	; CBufferFactory::GetInstance
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0GM@GGAAMOBM@?2Documents?5and?5Settings?2test?2Mes@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
CONST	SEGMENT
??_C@_0GM@GGAAMOBM@?2Documents?5and?5Settings?2test?2Mes@ DB '\Documents '
	DB	'and Settings\test\Mes documents\Source\Virtuos_v17\Build\Prog'
	DB	'ram\_Network\Net\Src\clientsock.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@ODKLMECE@CClientSocket?4Fetch?3?5ip?5?$DN?5?$CFs?0?5si@
CONST	SEGMENT
??_C@_0CI@ODKLMECE@CClientSocket?4Fetch?3?5ip?5?$DN?5?$CFs?0?5si@ DB 'CCl'
	DB	'ientSocket.Fetch: ip = %s, size = %d', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
CONST	ENDS
;	COMDAT ?Fetch@CClientSock@@QAEPAVCBuffer@@K@Z
_TEXT	SEGMENT
_pOld$ = -32						; size = 4
_ptr$ = -28						; size = 4
___loop$ = -24						; size = 4
_lpAddr$227660 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_dwBytes$ = 8						; size = 4
?Fetch@CClientSock@@QAEPAVCBuffer@@K@Z PROC NEAR	; CClientSock::Fetch, COMDAT
; _this$ = ecx

; 252  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	53		 push	 ebx
  0000b	8b d9		 mov	 ebx, ecx

; 253  : #ifdef __INFO_SOCKLIB0102
; 254  : 	if( m_dwReadHeaderSize == HEADERSIZE13 )
; 255  : 	{
; 256  : 		m_dwReadBytes	+= dwBytes;
; 257  : 		m_dwReadPacks++;
; 258  : 		time_t t	= time( NULL );
; 259  : 		if( t != m_tRead )
; 260  : 		{
; 261  : 			if( m_dwReadBytes > MAX_READ_BYTES_A_SEC )
; 262  : 			{
; 263  : 				OutputDebugString( "MAX_READ_BYTES_A_SEC" );
; 264  : 				return NULL;
; 265  : 			}
; 266  : 			if( m_dwReadPacks > MAX_READ_PACKS_A_SEC )
; 267  : 			{
; 268  : 				OutputDebugString( "MAX_READ_PACK_A_SEC" );
; 269  : 				return NULL;
; 270  : 			}
; 271  : 			char lpOutputString[100];
; 272  : 			sprintf( lpOutputString, "%d(bytes), %d(packets)", m_dwReadBytes, m_dwReadPacks );
; 273  : 			OutputDebugString( lpOutputString );
; 274  : 
; 275  : 			m_dwReadBytes	= m_dwReadPacks	= 0;
; 276  : 			m_tRead		= t;
; 277  : 		}
; 278  : 	}
; 279  : #endif	// __INFO_SOCKLIB0102
; 280  : 
; 281  : #ifdef __SO1014
; 282  : 	if( m_hSocket == INVALID_SOCKET )
; 283  : 	{
; 284  : 		WriteError( "FETCH//0" );
; 285  : 		WSASetLastError( ERROR_BAD_NET_NAME );
; 286  : 		return NULL;
; 287  : 	}
; 288  : /*
; 289  : 	if( m_dwReadHeaderSize == HEADERSIZE13 )
; 290  : 	{
; 291  : 		if( dwBytes > MAX_BUFFER )	//
; 292  : 		{
; 293  : 			WriteError( "FETCH//200//%d", dwBytes );
; 294  : 			WSASetLastError( ERROR_BAD_NET_NAME );
; 295  : 			return NULL;
; 296  : 		}
; 297  : 	}
; 298  : */
; 299  : #endif	// __SO1014
; 300  : 
; 301  : 	m_pRecvBuffer->m_pTail	+=	dwBytes;

  0000d	8b 4c 24 28	 mov	 ecx, DWORD PTR _dwBytes$[esp+32]
  00011	89 44 24 20	 mov	 DWORD PTR __$ArrayPad$[esp+36], eax
  00015	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00018	01 88 18 20 00
	00		 add	 DWORD PTR [eax+8216], ecx

; 302  : 
; 303  : //	ASSERT( m_pRecvBuffer->m_pTail <= m_pRecvBuffer->m_lpBufMax );
; 304  : //#ifdef __SO1014
; 305  : //	if( m_pRecvBuffer->m_pTail > m_pRecvBuffer->m_lpBufMax )
; 306  : //	{
; 307  : //		WriteError( "FETCH//1" );
; 308  : //		WSASetLastError( ERROR_BAD_NET_NAME );
; 309  : //		return NULL;
; 310  : //	}
; 311  : //#endif	// __SO1014
; 312  : 	
; 313  : 	int nRemnant;
; 314  : 	LPBYTE ptr	= m_pRecvBuffer->GetReadableBuffer( &nRemnant );

  0001e	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00021	8b 88 14 20 00
	00		 mov	 ecx, DWORD PTR [eax+8212]
  00027	55		 push	 ebp
  00028	8b a8 18 20 00
	00		 mov	 ebp, DWORD PTR [eax+8216]
  0002e	56		 push	 esi
  0002f	57		 push	 edi
  00030	2b e9		 sub	 ebp, ecx
  00032	8b f9		 mov	 edi, ecx

; 315  : 
; 316  : 	CBuffer* pOld	= NULL;

  00034	33 c0		 xor	 eax, eax
  00036	89 7c 24 14	 mov	 DWORD PTR _ptr$[esp+48], edi
  0003a	89 44 24 10	 mov	 DWORD PTR _pOld$[esp+48], eax
  0003e	8b ff		 npad	 2
$L227645:

; 317  : 	u_long uPacketSize;
; 318  : 
; 319  : #ifdef __CRC
; 320  : 	DWORD dwCrc, dwDataSize;
; 321  : 	byte digest[4];
; 322  : #endif	// __CRC
; 323  : 
; 324  : 	INIT_LOOP;
; 325  : 	while( 1 )
; 326  : 	{
; 327  : 		VERIFY_LOOP( __FILE__, __LINE__ );

  00040	40		 inc	 eax
  00041	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00046	89 44 24 18	 mov	 DWORD PTR ___loop$[esp+48], eax
  0004a	75 17		 jne	 SHORT $L227647
  0004c	68 47 01 00 00	 push	 327			; 00000147H
  00051	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GM@GGAAMOBM@?2Documents?5and?5Settings?2test?2Mes@
  00056	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  0005b	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
$L227647:

; 328  : #ifdef __CRC
; 329  : 		if( nRemnant < (int)( m_dwReadHeaderSize ) )
; 330  : #else	// __CRC
; 331  : 		if( nRemnant < (int)( m_pRecvBuffer->GetHeaderLength() ) )

  00063	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00066	8b b1 24 20 00
	00		 mov	 esi, DWORD PTR [ecx+8228]
  0006c	3b ee		 cmp	 ebp, esi
  0006e	7c 28		 jl	 SHORT $L228989

; 358  : 		}
; 359  : 		else
; 360  : 		{
; 361  : #ifdef __CRC
; 362  : 			if( m_dwReadHeaderSize == HEADERSIZE13 )
; 363  : 			{
; 364  : 				int nOffset	= sizeof(char);
; 365  : #ifdef __PACKET_REPLAY_R
; 366  : 				int nPacket	= *(UNALIGNED int*)( ptr + nOffset );
; 367  : 				nOffset	+= sizeof(int);
; 368  : 				if( nPacket != m_nPacket + 1 )
; 369  : 				{
; 370  : 					char lpAddr[16]		= { 0,};
; 371  : 					GetPeerAddr( DPID_UNKNOWN, lpAddr, NULL );
; 372  : 					Error( "CClientSock.Fetch: replay: %s", lpAddr );
; 373  : 					WSASetLastError( ERROR_BAD_NET_NAME );
; 374  : 					return NULL;
; 375  : 				}
; 376  : 				//m_nPacket++;
; 377  : #endif	// __PACKET_REPLAY_R
; 378  : 				dwCrc	= *(UNALIGNED LPDWORD)( ptr + nOffset );
; 379  : 				nOffset	+= sizeof(DWORD);
; 380  : 				dwDataSize	= *(UNALIGNED LPDWORD)( ptr + nOffset );
; 381  : 				nOffset	+= sizeof(DWORD);
; 382  : 				m_crcRead.Restart();
; 383  : 				m_crcRead.Update( (const byte*)( &dwDataSize ), sizeof(DWORD) );
; 384  : 				m_crcRead.Final( digest );
; 385  : #ifdef __PACKET_REPLAY_R
; 386  : 				if( ~( *(UNALIGNED LPDWORD)digest ^ ( m_dwProtocolId + nPacket ) ) != dwCrc )
; 387  : #else	// __PACKET_REPLAY_R
; 388  : 				if( ~( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 389  : #endif	// __PACKET_REPLAY_R
; 390  : 				{
; 391  : 					WSASetLastError( ERROR_BAD_NET_NAME );
; 392  : 					return NULL;
; 393  : 				}
; 394  : 				dwCrc	= *(UNALIGNED LPDWORD)( ptr + nOffset );
; 395  : 				nOffset	+= sizeof(DWORD);
; 396  : 				uPacketSize		= m_dwReadHeaderSize + dwDataSize;
; 397  : #ifdef __SO1014
; 398  : 				if( dwDataSize > MAX_BUFFER )	// if( uPacketSize > MAX_BUFFER )	// kang: 2008/08/14
; 399  : 				{
; 400  : 					char lpAddr[16]		= { 0,};
; 401  : 					GetPeerAddr( DPID_UNKNOWN, lpAddr, NULL );
; 402  : 					Error( "CClientSocket.Fetch: ip = %s, size = %d", lpAddr, dwDataSize );
; 403  : 					WSASetLastError( ERROR_BAD_NET_NAME );
; 404  : 					return NULL;
; 405  : 				}
; 406  : #endif	// __SO1014
; 407  : 			}
; 408  : 			else
; 409  : 			{
; 410  : 				uPacketSize	= m_dwReadHeaderSize + *(UNALIGNED LPDWORD)&ptr[1];
; 411  : 			}
; 412  : #else	// __CRC
; 413  : 			uPacketSize	= m_pRecvBuffer->GetHeaderLength() + m_pRecvBuffer->GetPacketSize( ptr );

  00070	8b 11		 mov	 edx, DWORD PTR [ecx]
  00072	57		 push	 edi
  00073	ff 52 04	 call	 DWORD PTR [edx+4]
  00076	8b f8		 mov	 edi, eax

; 442  : 				}
; 443  : 				return pOld;
; 444  : 			}
; 445  : 			else	// completion
; 446  : 			{
; 447  : #ifdef __CRC
; 448  : 				if( m_dwReadHeaderSize == HEADERSIZE13 )
; 449  : 				{
; 450  : 					m_crcRead.Restart();
; 451  : 					m_crcRead.Update( (const byte*)( ptr + m_dwReadHeaderSize ), dwDataSize );
; 452  : 					m_crcRead.Final( digest );
; 453  : #ifdef __PACKET_REPLAY_R
; 454  : 					if( ~( *(UNALIGNED LPDWORD)digest ^ ( m_dwProtocolId + m_nPacket + 1 ) ) != dwCrc )
; 455  : #else	// __PACKET_REPLAY_R
; 456  : 					if( ~( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 457  : #endif	// __PACKET_REPLAY_R
; 458  : 					{
; 459  : 						char lpAddr[16]		= { 0,};
; 460  : 						GetPeerAddr( DPID_UNKNOWN, lpAddr, NULL );
; 461  : 						Error( "CClientSock.Fetch: replay: %s", lpAddr );
; 462  : 						WSASetLastError( ERROR_BAD_NET_NAME );
; 463  : 						return NULL;
; 464  : 					}
; 465  : 				}
; 466  : #endif	// __CRC
; 467  : #ifdef __PACKET_REPLAY_R
; 468  : 				m_nPacket++;
; 469  : #endif // __PACKET_REPLAY_R
; 470  : 				m_pRecvBuffer->cb++;

  00078	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0007b	03 fe		 add	 edi, esi
  0007d	3b ef		 cmp	 ebp, edi
  0007f	7c 59		 jl	 SHORT $L228990
  00081	ff 40 08	 inc	 DWORD PTR [eax+8]

; 471  : 				nRemnant	-= ( uPacketSize );
; 472  : 				ptr		+= ( uPacketSize );

  00084	8b 44 24 14	 mov	 eax, DWORD PTR _ptr$[esp+48]
  00088	2b ef		 sub	 ebp, edi
  0008a	03 c7		 add	 eax, edi
  0008c	89 44 24 14	 mov	 DWORD PTR _ptr$[esp+48], eax

; 473  : 			}
; 474  : 		}
; 475  : 	}

  00090	8b f8		 mov	 edi, eax
  00092	8b 44 24 18	 mov	 eax, DWORD PTR ___loop$[esp+48]
  00096	eb a8		 jmp	 SHORT $L227645
$L228989:

; 332  : #endif	// __CRC
; 333  : 		{
; 334  : 			if( m_pRecvBuffer->cb > 0 ) {

  00098	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0009b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009e	85 c9		 test	 ecx, ecx
  000a0	0f 86 fa 00 00
	00		 jbe	 $L228991

; 335  : 				pOld	= m_pRecvBuffer;
; 336  : 				pOld->m_pTail	-= nRemnant;	// remove remnant from old buffer

  000a6	8b b0 18 20 00
	00		 mov	 esi, DWORD PTR [eax+8216]
  000ac	2b f5		 sub	 esi, ebp
  000ae	89 44 24 10	 mov	 DWORD PTR _pOld$[esp+48], eax
  000b2	89 b0 18 20 00
	00		 mov	 DWORD PTR [eax+8216], esi

; 337  : 				m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( m_nBufferType );

  000b8	8b 83 8c 04 00
	00		 mov	 eax, DWORD PTR [ebx+1164]
  000be	68 00 20 00 00	 push	 8192			; 00002000H
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  000c9	8b c8		 mov	 ecx, eax
  000cb	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer
  000d0	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 338  : //				ASSERT( m_pRecvBuffer->m_pTail + nRemnant <= m_pRecvBuffer->m_lpBufMax ); 
; 339  : #ifdef __SO1014
; 340  : //				if( m_pRecvBuffer->m_pTail + nRemnant > m_pRecvBuffer->m_lpBufMax )
; 341  : //				{
; 342  : //					WriteError( "FETCH//2" );
; 343  : //					WSASetLastError( ERROR_BAD_NET_NAME );
; 344  : //					return NULL;
; 345  : //				}
; 346  : 				if( !m_pRecvBuffer->m_lpBufStart )
; 347  : 				{
; 348  : 					WriteError( "FETCH//2" );
; 349  : 					WSASetLastError( ERROR_BAD_NET_NAME );
; 350  : 					return NULL;
; 351  : 				}
; 352  : #endif	// __SO1014
; 353  : 				memcpy( m_pRecvBuffer->m_pTail, ptr, nRemnant );

  000d3	8b f7		 mov	 esi, edi

; 354  : 
; 355  : 				m_pRecvBuffer->m_pTail	+=	nRemnant;
; 356  : 			}
; 357  : 			return pOld;

  000d5	e9 a7 00 00 00	 jmp	 $L228994
$L228990:

; 414  : #endif	// __CRC
; 415  : 			if( nRemnant < (int)( uPacketSize ) )
; 416  : 			{
; 417  : 				if( (int)( uPacketSize ) > m_pRecvBuffer->GetSize() || m_pRecvBuffer->cb > 0 )

  000da	8b 88 10 20 00
	00		 mov	 ecx, DWORD PTR [eax+8208]
  000e0	2b 88 0c 20 00
	00		 sub	 ecx, DWORD PTR [eax+8204]
  000e6	3b f9		 cmp	 edi, ecx
  000e8	7f 0b		 jg	 SHORT $L228992
  000ea	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000ed	85 c9		 test	 ecx, ecx
  000ef	0f 86 ab 00 00
	00		 jbe	 $L228991
$L228992:

; 418  : 				{
; 419  : 					pOld	= m_pRecvBuffer;
; 420  : 					m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( m_nBufferType, uPacketSize ); 

  000f5	8b 93 8c 04 00
	00		 mov	 edx, DWORD PTR [ebx+1164]
  000fb	8b f0		 mov	 esi, eax
  000fd	57		 push	 edi
  000fe	52		 push	 edx
  000ff	89 74 24 18	 mov	 DWORD PTR _pOld$[esp+56], esi
  00103	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00108	8b c8		 mov	 ecx, eax
  0010a	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer
  0010f	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 421  : 					if( !m_pRecvBuffer->m_lpBufStart )

  00112	8b 88 0c 20 00
	00		 mov	 ecx, DWORD PTR [eax+8204]
  00118	85 c9		 test	 ecx, ecx
  0011a	75 5d		 jne	 SHORT $L227659

; 422  : 					{
; 423  : 						char lpAddr[16]		= { 0,};
; 424  : 						GetPeerAddr( DPID_UNKNOWN, lpAddr, NULL );

  0011c	8b 13		 mov	 edx, DWORD PTR [ebx]
  0011e	33 c0		 xor	 eax, eax
  00120	89 44 24 1d	 mov	 DWORD PTR _lpAddr$227660[esp+49], eax
  00124	89 44 24 21	 mov	 DWORD PTR _lpAddr$227660[esp+53], eax
  00128	89 44 24 25	 mov	 DWORD PTR _lpAddr$227660[esp+57], eax
  0012c	66 89 44 24 29	 mov	 WORD PTR _lpAddr$227660[esp+61], ax
  00131	88 44 24 2b	 mov	 BYTE PTR _lpAddr$227660[esp+63], al
  00135	8b cb		 mov	 ecx, ebx
  00137	c6 44 24 1c 00	 mov	 BYTE PTR _lpAddr$227660[esp+48], 0
  0013c	50		 push	 eax
  0013d	8d 44 24 20	 lea	 eax, DWORD PTR _lpAddr$227660[esp+52]
  00141	50		 push	 eax
  00142	6a ff		 push	 -1
  00144	ff 52 18	 call	 DWORD PTR [edx+24]

; 425  : 						Error( "CClientSocket.Fetch: ip = %s, size = %d", lpAddr, uPacketSize );

  00147	57		 push	 edi
  00148	8d 4c 24 20	 lea	 ecx, DWORD PTR _lpAddr$227660[esp+52]
  0014c	51		 push	 ecx
  0014d	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0CI@ODKLMECE@CClientSocket?4Fetch?3?5ip?5?$DN?5?$CFs?0?5si@
  00152	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH

; 426  : 						WSASetLastError( ERROR_BAD_NET_NAME );

  0015a	6a 43		 push	 67			; 00000043H
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASetLastError@4
  00162	5f		 pop	 edi
  00163	5e		 pop	 esi
  00164	5d		 pop	 ebp

; 427  : 						return NULL;

  00165	33 c0		 xor	 eax, eax
  00167	5b		 pop	 ebx

; 476  : 
; 477  : 
; 478  : 
; 479  : 	return NULL;
; 480  : }

  00168	8b 4c 24 1c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+32]
  0016c	33 cc		 xor	 ecx, esp
  0016e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00173	83 c4 20	 add	 esp, 32			; 00000020H
  00176	c2 04 00	 ret	 4
$L227659:

; 428  : 					}
; 429  : 				}
; 430  : 				if( pOld )

  00179	85 f6		 test	 esi, esi
  0017b	74 23		 je	 SHORT $L228991

; 431  : 				{
; 432  : #ifdef __SO1014
; 433  : 					if( !m_pRecvBuffer->m_lpBufStart )
; 434  : 					{
; 435  : 						WriteError( "FETCH//3" );
; 436  : 						WSASetLastError( ERROR_BAD_NET_NAME );
; 437  : 						return NULL;
; 438  : 					}
; 439  : #endif	// __SO1014
; 440  : 					memcpy( m_pRecvBuffer->m_pTail, ptr, nRemnant );

  0017d	8b 74 24 14	 mov	 esi, DWORD PTR _ptr$[esp+48]
$L228994:
  00181	8b b8 18 20 00
	00		 mov	 edi, DWORD PTR [eax+8216]
  00187	8b cd		 mov	 ecx, ebp
  00189	8b d1		 mov	 edx, ecx
  0018b	c1 e9 02	 shr	 ecx, 2
  0018e	f3 a5		 rep movsd
  00190	8b ca		 mov	 ecx, edx
  00192	83 e1 03	 and	 ecx, 3
  00195	f3 a4		 rep movsb

; 441  : 					m_pRecvBuffer->m_pTail	+=	nRemnant;

  00197	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  0019a	01 ab 18 20 00
	00		 add	 DWORD PTR [ebx+8216], ebp
$L228991:

; 476  : 
; 477  : 
; 478  : 
; 479  : 	return NULL;
; 480  : }

  001a0	8b 4c 24 2c	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+48]
  001a4	8b 44 24 10	 mov	 eax, DWORD PTR _pOld$[esp+48]
  001a8	5f		 pop	 edi
  001a9	5e		 pop	 esi
  001aa	5d		 pop	 ebp
  001ab	5b		 pop	 ebx
  001ac	33 cc		 xor	 ecx, esp
  001ae	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001b3	83 c4 20	 add	 esp, 32			; 00000020H
  001b6	c2 04 00	 ret	 4
?Fetch@CClientSock@@QAEPAVCBuffer@@K@Z ENDP		; CClientSock::Fetch
_TEXT	ENDS
PUBLIC	?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z		; CClientSock::GetPeerAddr
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
EXTRN	__imp__getpeername@12:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z
_TEXT	SEGMENT
_namelen$ = -24						; size = 4
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_dpidPlayer$ = 8					; size = 4
_lpAddr$ = 12						; size = 4
_lpdwSize$ = 16						; size = 4
?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z PROC NEAR	; CClientSock::GetPeerAddr, COMDAT
; _this$ = ecx

; 483  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 484  : 	ASSERT( lpAddr );
; 485  : 
; 486  : 	SOCKADDR_IN sin;
; 487  : 	ZeroMemory( &sin, sizeof( SOCKADDR_IN) );
; 488  : 
; 489  : 	int namelen	= sizeof(sin);
; 490  : 	if( getpeername( m_hSocket, (SOCKADDR *)&sin, &namelen ) == SOCKET_ERROR )

  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	33 c4		 xor	 eax, esp
  0000d	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax
  00011	33 c0		 xor	 eax, eax
  00013	89 44 24 04	 mov	 DWORD PTR _sin$[esp+24], eax
  00017	89 44 24 08	 mov	 DWORD PTR _sin$[esp+28], eax
  0001b	56		 push	 esi
  0001c	8b 74 24 24	 mov	 esi, DWORD PTR _lpAddr$[esp+24]
  00020	89 44 24 10	 mov	 DWORD PTR _sin$[esp+36], eax
  00024	8d 54 24 04	 lea	 edx, DWORD PTR _namelen$[esp+28]
  00028	89 44 24 14	 mov	 DWORD PTR _sin$[esp+40], eax
  0002c	52		 push	 edx
  0002d	8d 44 24 0c	 lea	 eax, DWORD PTR _sin$[esp+32]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	c7 44 24 10 10
	00 00 00	 mov	 DWORD PTR _namelen$[esp+40], 16 ; 00000010H
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getpeername@12
  00041	83 f8 ff	 cmp	 eax, -1
  00044	75 17		 jne	 SHORT $L227675

; 491  : 		return DPERR_GENERIC;

  00046	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0004b	5e		 pop	 esi

; 497  : 	return DP_OK;
; 498  : }

  0004c	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00050	33 cc		 xor	 ecx, esp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$L227675:

; 492  : 
; 493  : 	sprintf( (char *)lpAddr, "%d.%d.%d.%d", sin.sin_addr.s_net
; 494  : 																	, sin.sin_addr.s_host
; 495  : 																	, sin.sin_addr.s_lh
; 496  : 																	, sin.sin_addr.s_impno );

  0005d	0f b6 54 24 0f	 movzx	 edx, BYTE PTR _sin$[esp+35]
  00062	0f b6 44 24 0e	 movzx	 eax, BYTE PTR _sin$[esp+34]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	8b 44 24 14	 mov	 eax, DWORD PTR _sin$[esp+40]
  0006d	0f b6 cc	 movzx	 ecx, ah
  00070	51		 push	 ecx
  00071	0f b6 d0	 movzx	 edx, al
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 _sprintf

; 497  : 	return DP_OK;
; 498  : }

  00080	8b 4c 24 30	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  00084	83 c4 18	 add	 esp, 24			; 00000018H
  00087	5e		 pop	 esi
  00088	33 cc		 xor	 ecx, esp
  0008a	33 c0		 xor	 eax, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	83 c4 18	 add	 esp, 24			; 00000018H
  00094	c2 0c 00	 ret	 12			; 0000000cH
?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z ENDP		; CClientSock::GetPeerAddr
_TEXT	ENDS
PUBLIC	?CreateBuffer@CClientSock@@QAEPAVCBuffer@@XZ	; CClientSock::CreateBuffer
; Function compile flags: /Ogty
;	COMDAT ?CreateBuffer@CClientSock@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT
?CreateBuffer@CClientSock@@QAEPAVCBuffer@@XZ PROC NEAR	; CClientSock::CreateBuffer, COMDAT
; _this$ = ecx

; 502  : 	return CBufferFactory::GetInstance().CreateBuffer( m_nBufferType );

  00000	8b 81 8c 04 00
	00		 mov	 eax, DWORD PTR [ecx+1164]
  00006	68 00 20 00 00	 push	 8192			; 00002000H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 503  : }

  00018	c3		 ret	 0
?CreateBuffer@CClientSock@@QAEPAVCBuffer@@XZ ENDP	; CClientSock::CreateBuffer
_TEXT	ENDS
PUBLIC	??0CMclCritSec@@QAE@XZ				; CMclCritSec::CMclCritSec
PUBLIC	??_7CMclCritSec@@6B@				; CMclCritSec::`vftable'
PUBLIC	??_GCMclCritSec@@UAEPAXI@Z			; CMclCritSec::`scalar deleting destructor'
EXTRN	??_ECMclCritSec@@UAEPAXI@Z:NEAR			; CMclCritSec::`vector deleting destructor'
EXTRN	__imp__InitializeCriticalSection@4:NEAR
;	COMDAT ??_7CMclCritSec@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
CONST	SEGMENT
??_7CMclCritSec@@6B@ DD FLAT:??_ECMclCritSec@@UAEPAXI@Z	; CMclCritSec::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT
??0CMclCritSec@@QAE@XZ PROC NEAR			; CMclCritSec::CMclCritSec, COMDAT
; _this$ = ecx

; 19   :     CMclCritSec(void)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 20   :     {
; 21   : 		::InitializeCriticalSection( &m_CritSec );

  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CMclCritSec@@6B@
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 22   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??0CMclCritSec@@QAE@XZ ENDP				; CMclCritSec::CMclCritSec
_TEXT	ENDS
PUBLIC	??1CMclCritSec@@UAE@XZ				; CMclCritSec::~CMclCritSec
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT
??1CMclCritSec@@UAE@XZ PROC NEAR			; CMclCritSec::~CMclCritSec, COMDAT
; _this$ = ecx

; 26   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CMclCritSec@@6B@

; 27   : 		::DeleteCriticalSection( &m_CritSec );

  00006	83 c1 04	 add	 ecx, 4
  00009	51		 push	 ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 28   : 	}

  00010	c3		 ret	 0
??1CMclCritSec@@UAE@XZ ENDP				; CMclCritSec::~CMclCritSec
_TEXT	ENDS
PUBLIC	?Enter@CMclCritSec@@QAEXXZ			; CMclCritSec::Enter
EXTRN	__imp__EnterCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Enter@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Enter, COMDAT
; _this$ = ecx

; 33   : 		::EnterCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 34   : 	}

  0000a	c3		 ret	 0
?Enter@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Enter
_TEXT	ENDS
PUBLIC	?Leave@CMclCritSec@@QAEXXZ			; CMclCritSec::Leave
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Leave@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Leave, COMDAT
; _this$ = ecx

; 39   : 		::LeaveCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 40   : 	}

  0000a	c3		 ret	 0
?Leave@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Leave
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMclCritSec@@UAEPAXI@Z PROC NEAR			; CMclCritSec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CMclCritSec@@6B@
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00013	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00018	74 09		 je	 SHORT $L229023
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L229023:
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	c2 04 00	 ret	 4
??_GCMclCritSec@@UAEPAXI@Z ENDP				; CMclCritSec::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z		; CMclAutoLock::CMclAutoLock
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclautolock.h
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT
_rCMclCritSec$ = 8					; size = 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z PROC NEAR	; CMclAutoLock::CMclAutoLock, COMDAT
; _this$ = ecx

; 20   : 	{
; 21   : 		m_pcCritSec = &rCMclCritSec;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _rCMclCritSec$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 22   : 		m_pcCritSec->Enter();

  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 23   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z ENDP		; CMclAutoLock::CMclAutoLock
_TEXT	ENDS
PUBLIC	??1CMclAutoLock@@QAE@XZ				; CMclAutoLock::~CMclAutoLock
; Function compile flags: /Ogty
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT
??1CMclAutoLock@@QAE@XZ PROC NEAR			; CMclAutoLock::~CMclAutoLock, COMDAT
; _this$ = ecx

; 28   : 		m_pcCritSec->Leave();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4
  00005	50		 push	 eax
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 29   : 	}

  0000c	c3		 ret	 0
??1CMclAutoLock@@QAE@XZ ENDP				; CMclAutoLock::~CMclAutoLock
_TEXT	ENDS
PUBLIC	??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z		; CClientSock::CClientSock
PUBLIC	?Send@CClientSock@@UAEXPADKK@Z			; CClientSock::Send
PUBLIC	?GetPeerAddr@CClientSock@@UAEKK@Z		; CClientSock::GetPeerAddr
PUBLIC	??_7CClientSock@@6B@				; CClientSock::`vftable'
PUBLIC	??_GCClientSock@@UAEPAXI@Z			; CClientSock::`scalar deleting destructor'
PUBLIC	?Get@CSock@@UAEPAV1@I@Z				; CSock::Get
EXTRN	??0CBufferQueue@@QAE@XZ:NEAR			; CBufferQueue::CBufferQueue
EXTRN	??1CBufferQueue@@UAE@XZ:NEAR			; CBufferQueue::~CBufferQueue
EXTRN	??_ECClientSock@@UAEPAXI@Z:NEAR			; CClientSock::`vector deleting destructor'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0CSock@@QAE@XZ:NEAR				; CSock::CSock
EXTRN	??1CSock@@UAE@XZ:NEAR				; CSock::~CSock
EXTRN	?Create@CSock@@UAEHGH@Z:NEAR			; CSock::Create
EXTRN	?Attach@CSock@@UAEXI@Z:NEAR			; CSock::Attach
EXTRN	?Detach@CSock@@UAEXXZ:NEAR			; CSock::Detach
EXTRN	?GetHostAddr@CSock@@UAEJPAXPAK@Z:NEAR		; CSock::GetHostAddr
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229054 DD	0ffffffffH
	DD	FLAT:$L229041
	DD	00H
	DD	FLAT:$L229042
	DD	01H
	DD	FLAT:$L229043
$T229051 DD	019930520H
	DD	03H
	DD	FLAT:$T229054
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CClientSock@@6B@
CONST	SEGMENT
??_7CClientSock@@6B@ DD FLAT:??_ECClientSock@@UAEPAXI@Z	; CClientSock::`vftable'
	DD	FLAT:?Create@CSock@@UAEHGH@Z
	DD	FLAT:?Attach@CSock@@UAEXI@Z
	DD	FLAT:?Detach@CSock@@UAEXXZ
	DD	FLAT:?GetHostAddr@CSock@@UAEJPAXPAK@Z
	DD	FLAT:?GetPeerAddr@CClientSock@@UAEKK@Z
	DD	FLAT:?GetPeerAddr@CClientSock@@UAEJKPAXPAK@Z
	DD	FLAT:?Close@CClientSock@@UAEXXZ
	DD	FLAT:?CloseConnection@CClientSock@@UAEHI@Z
	DD	FLAT:?Shutdown@CClientSock@@UAEHI@Z
	DD	FLAT:?Send@CClientSock@@UAEXPADKK@Z
	DD	FLAT:?Get@CSock@@UAEPAV1@I@Z
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
CONST	ENDS
;	COMDAT ??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z PROC NEAR		; CClientSock::CClientSock, COMDAT
; _this$ = ecx

; 50   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	53		 push	 ebx
  00017	56		 push	 esi
  00018	8b f1		 mov	 esi, ecx
  0001a	57		 push	 edi
  0001b	89 74 24 0c	 mov	 DWORD PTR _this$[esp+28], esi
  0001f	e8 00 00 00 00	 call	 ??0CSock@@QAE@XZ	; CSock::CSock
  00024	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  00027	33 db		 xor	 ebx, ebx
  00029	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CClientSock@@6B@
  0002f	50		 push	 eax
  00030	89 5c 24 1c	 mov	 DWORD PTR __$EHRec$[esp+40], ebx
  00034	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], OFFSET FLAT:??_7CMclCritSec@@6B@
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4
  00041	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00044	c6 44 24 18 01	 mov	 BYTE PTR __$EHRec$[esp+36], 1
  00049	e8 00 00 00 00	 call	 ??0CBufferQueue@@QAE@XZ	; CBufferQueue::CBufferQueue

; 51   : #ifdef __CRC
; 52   : 	m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( BUFFER_TYPE_5BYTE );
; 53   : 	if( CSock::crcRead & dwcrc )
; 54   : 		m_dwReadHeaderSize	= HEADERSIZE13;
; 55   : 	else
; 56   : 		m_dwReadHeaderSize	= HEADERSIZE5;
; 57   : 
; 58   : #ifdef __PROTOCOL0910
; 59   : 	m_dwProtocolId	= 0;
; 60   : #endif	// __PROTOCOL0910
; 61   : 	
; 62   : 	if( CSock::crcWrite & dwcrc )
; 63   : #ifdef __PROTOCOL0910
; 64   : 		m_lspSendBuffer.crc( &m_crcWrite, &m_dwProtocolId );
; 65   : #else	// __PROTOCOL0910
; 66   : 		m_lspSendBuffer.crc( &m_crcWrite );
; 67   : #endif	// __PROTOCOL0910
; 68   : 	m_nBufferType = BUFFER_TYPE_5BYTE;
; 69   : #else	// __CRC
; 70   : //	m_l	= 0;
; 71   : 	m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( type );

  0004e	8b 7c 24 20	 mov	 edi, DWORD PTR _type$[esp+24]
  00052	68 00 20 00 00	 push	 8192			; 00002000H
  00057	57		 push	 edi
  00058	c6 44 24 20 02	 mov	 BYTE PTR __$EHRec$[esp+44], 2
  0005d	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00062	8b c8		 mov	 ecx, eax
  00064	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 72   : 	m_nBufferType = type;
; 73   : #endif	// __CRC
; 74   : 
; 75   : #ifdef __PACKET_REPLAY_R
; 76   : 	m_nPacket	= 0;
; 77   : #endif	// __PACKET_REPLAY_R
; 78   : 
; 79   : 	m_dwAddr	= 0;
; 80   : 
; 81   : 	m_bDoNotWrite	= FALSE;
; 82   : 	m_nReference	= 0;
; 83   : #ifdef __INFO_SOCKLIB0516
; 84   : 	m_dwDbgInfo		= 0;
; 85   : #endif	// __INFO_SOCKLIB0516
; 86   : 
; 87   : #ifdef __INFO_SOCKLIB0102
; 88   : 	m_dwReadBytes	= 0;
; 89   : 	m_dwReadPacks	= 0;
; 90   : 	m_tRead	= time( NULL );
; 91   : #endif	// __INFO_SOCKLIB0102
; 92   : }

  00069	8b 4c 24 10	 mov	 ecx, DWORD PTR __$EHRec$[esp+28]
  0006d	89 be 8c 04 00
	00		 mov	 DWORD PTR [esi+1164], edi
  00073	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00076	89 9e 90 04 00
	00		 mov	 DWORD PTR [esi+1168], ebx
  0007c	89 5e 3c	 mov	 DWORD PTR [esi+60], ebx
  0007f	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx
  00082	5f		 pop	 edi
  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx
  00087	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0008e	83 c4 10	 add	 esp, 16			; 00000010H
  00091	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229041:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CSock@@UAE@XZ	; CSock::~CSock
$L229042:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 40	 add	 ecx, 64			; 00000040H
  0000e	e9 00 00 00 00	 jmp	 ??1CMclCritSec@@UAE@XZ	; CMclCritSec::~CMclCritSec
$L229043:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
__ehhandler$??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z:
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229051
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CClientSock@@QAE@W4BUFFER_TYPE@@@Z ENDP		; CClientSock::CClientSock
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\sock.h
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Get@CSock@@UAEPAV1@I@Z PROC NEAR			; CSock::Get, COMDAT
; _this$ = ecx

; 51   : inline CSock* CSock::Get( SOCKET hSocket )	{	return( m_hSocket == hSocket ? this : NULL );	}

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	8b 74 24 08	 mov	 esi, DWORD PTR _hSocket$[esp]
  00008	33 c0		 xor	 eax, eax
  0000a	3b d6		 cmp	 edx, esi
  0000c	0f 95 c0	 setne	 al
  0000f	5e		 pop	 esi
  00010	48		 dec	 eax
  00011	23 c1		 and	 eax, ecx
  00013	c2 04 00	 ret	 4
?Get@CSock@@UAEPAV1@I@Z ENDP				; CSock::Get
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\clientsock.h
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CClientSock@@UAEKK@Z
_TEXT	SEGMENT
_dpid$ = 8						; size = 4
?GetPeerAddr@CClientSock@@UAEKK@Z PROC NEAR		; CClientSock::GetPeerAddr, COMDAT
; _this$ = ecx

; 80   : 	virtual	DWORD	GetPeerAddr( DPID dpid ) { return m_dwAddr; }

  00000	8b 81 90 04 00
	00		 mov	 eax, DWORD PTR [ecx+1168]
  00006	c2 04 00	 ret	 4
?GetPeerAddr@CClientSock@@UAEKK@Z ENDP			; CClientSock::GetPeerAddr
_TEXT	ENDS
PUBLIC	??1CClientSock@@UAE@XZ				; CClientSock::~CClientSock
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229090 DD	0ffffffffH
	DD	FLAT:$L229067
	DD	00H
	DD	FLAT:$L229068
	DD	01H
	DD	FLAT:$L229069
$T229088 DD	019930520H
	DD	03H
	DD	FLAT:$T229090
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
xdata$x	ENDS
;	COMDAT ??1CClientSock@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CClientSock@@UAE@XZ PROC NEAR			; CClientSock::~CClientSock, COMDAT
; _this$ = ecx

; 95   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1CClientSock@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CClientSock@@6B@

; 96   : 	Close();

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	83 f8 ff	 cmp	 eax, -1
  00029	c7 44 24 10 02
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 2
  00031	74 1a		 je	 SHORT $L229076
  00033	6a 02		 push	 2
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  0003c	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0003f	50		 push	 eax
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00046	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L229076:
  0004d	8b 4e 10	 mov	 ecx, DWORD PTR [esi+16]
  00050	85 c9		 test	 ecx, ecx
  00052	74 0d		 je	 SHORT $L229077
  00054	8b 11		 mov	 edx, DWORD PTR [ecx]
  00056	6a 01		 push	 1
  00058	ff 12		 call	 DWORD PTR [edx]
  0005a	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$L229077:

; 97   : }

  00061	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00064	c6 44 24 10 01	 mov	 BYTE PTR __$EHRec$[esp+28], 1
  00069	e8 00 00 00 00	 call	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
  0006e	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  00071	50		 push	 eax
  00072	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], OFFSET FLAT:??_7CMclCritSec@@6B@
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  0007f	8b ce		 mov	 ecx, esi
  00081	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  00089	e8 00 00 00 00	 call	 ??1CSock@@UAE@XZ	; CSock::~CSock
  0008e	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00092	5e		 pop	 esi
  00093	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0009a	83 c4 10	 add	 esp, 16			; 00000010H
  0009d	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229067:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CSock@@UAE@XZ	; CSock::~CSock
$L229068:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 40	 add	 ecx, 64			; 00000040H
  0000e	e9 00 00 00 00	 jmp	 ??1CMclCritSec@@UAE@XZ	; CMclCritSec::~CMclCritSec
$L229069:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 60	 add	 ecx, 96			; 00000060H
  00019	e9 00 00 00 00	 jmp	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
__ehhandler$??1CClientSock@@UAE@XZ:
  0001e	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229088
  00023	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CClientSock@@UAE@XZ ENDP				; CClientSock::~CClientSock
EXTRN	?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z:NEAR ; CBufferQueue::AddData
EXTRN	?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z:NEAR ; CBufferQueue::GetData
EXTRN	__imp__WSASend@28:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229156 DD	0ffffffffH
	DD	FLAT:$L229096
	DD	00H
	DD	FLAT:$L229097
$T229151 DD	019930520H
	DD	02H
	DD	FLAT:$T229156
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
xdata$x	ENDS
;	COMDAT ?Send@CClientSock@@UAEXPADKK@Z
_TEXT	SEGMENT
tv197 = -32						; size = 4
_dwBufferCount$ = -28					; size = 4
_Lock1$ = -24						; size = 4
_Lock$ = -20						; size = 4
_dwBytes$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
_dwDataSize$ = 12					; size = 4
_dpidTo$ = 16						; size = 4
?Send@CClientSock@@UAEXPADKK@Z PROC NEAR		; CClientSock::Send, COMDAT
; _this$ = ecx

; 169  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  00006	6a ff		 push	 -1
  00008	68 00 00 00 00	 push	 __ehhandler$?Send@CClientSock@@UAEXPADKK@Z
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 14	 sub	 esp, 20			; 00000014H
  00018	56		 push	 esi
  00019	8b f1		 mov	 esi, ecx

; 170  : //	ASSERT( m_hSocket != INVALID_SOCKET );
; 171  : 	if( m_hSocket == INVALID_SOCKET )

  0001b	83 7e 04 ff	 cmp	 DWORD PTR [esi+4], -1
  0001f	0f 84 ec 00 00
	00		 je	 $L227588
  00025	53		 push	 ebx

; 172  : 		return;
; 173  : 
; 174  : 	DWORD dwBufferCount, dwBytes;
; 175  : 	CMclAutoLock	Lock1( m_AccessLock );

  00026	8d 46 40	 lea	 eax, DWORD PTR [esi+64]
  00029	57		 push	 edi
  0002a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__EnterCriticalSection@4
  00030	8d 58 04	 lea	 ebx, DWORD PTR [eax+4]
  00033	53		 push	 ebx
  00034	89 44 24 18	 mov	 DWORD PTR _Lock1$[esp+48], eax
  00038	89 5c 24 10	 mov	 DWORD PTR tv197[esp+48], ebx
  0003c	ff d7		 call	 edi

; 176  : 	if( m_bDoNotWrite )

  0003e	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00041	85 c0		 test	 eax, eax
  00043	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+52], 0
  0004b	74 1b		 je	 SHORT $L227594

; 177  : 		return;

  0004d	53		 push	 ebx
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00054	5f		 pop	 edi
  00055	5b		 pop	 ebx
  00056	5e		 pop	 esi

; 200  : 	}
; 201  : }

  00057	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00062	83 c4 20	 add	 esp, 32			; 00000020H
  00065	c2 0c 00	 ret	 12			; 0000000cH
$L227594:

; 178  : 	CMclAutoLock	Lock( m_lspSendBuffer.m_cs );

  00068	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  0006b	55		 push	 ebp
  0006c	8d 68 04	 lea	 ebp, DWORD PTR [eax+4]
  0006f	55		 push	 ebp
  00070	89 44 24 20	 mov	 DWORD PTR _Lock$[esp+52], eax
  00074	ff d7		 call	 edi

; 179  : 
; 180  : 	if( m_lspSendBuffer.IsEmpty() )

  00076	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]

; 181  : 	{
; 182  : 		m_lspSendBuffer.AddData( (LPBYTE)lpData, dwDataSize, m_nBufferType );

  00079	8b 4c 24 38	 mov	 ecx, DWORD PTR _dwDataSize$[esp+44]
  0007d	8b 54 24 34	 mov	 edx, DWORD PTR _lpData$[esp+44]
  00081	85 c0		 test	 eax, eax
  00083	8b 86 8c 04 00
	00		 mov	 eax, DWORD PTR [esi+1164]
  00089	50		 push	 eax
  0008a	51		 push	 ecx
  0008b	c6 44 24 34 01	 mov	 BYTE PTR __$EHRec$[esp+64], 1
  00090	52		 push	 edx
  00091	0f 85 8c 00 00
	00		 jne	 $L227596
  00097	8d 7e 60	 lea	 edi, DWORD PTR [esi+96]
  0009a	8b cf		 mov	 ecx, edi
  0009c	e8 00 00 00 00	 call	 ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ; CBufferQueue::AddData

; 183  : 		m_lspSendBuffer.GetData( m_lpBuffers, &dwBufferCount );

  000a1	8d 44 24 14	 lea	 eax, DWORD PTR _dwBufferCount$[esp+48]
  000a5	50		 push	 eax
  000a6	8d 9e 8c 00 00
	00		 lea	 ebx, DWORD PTR [esi+140]
  000ac	53		 push	 ebx
  000ad	8b cf		 mov	 ecx, edi
  000af	e8 00 00 00 00	 call	 ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z ; CBufferQueue::GetData

; 184  : 
; 185  : 		memset( (void*)&m_ovSend, 0, sizeof(WSAOVERLAPPED) );

  000b4	33 c9		 xor	 ecx, ecx
  000b6	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  000b9	8b d0		 mov	 edx, eax
  000bb	89 0a		 mov	 DWORD PTR [edx], ecx
  000bd	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  000c0	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 186  : 		int err;
; 187  : 		m_nReference++;
; 188  : 		if( WSASend( GetHandle(), m_lpBuffers, dwBufferCount, &dwBytes, 0, &m_ovSend, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  000c3	6a 00		 push	 0
  000c5	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  000c8	50		 push	 eax
  000c9	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  000cc	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  000cf	8b 54 24 1c	 mov	 edx, DWORD PTR _dwBufferCount$[esp+56]
  000d3	6a 00		 push	 0
  000d5	8d 44 24 2c	 lea	 eax, DWORD PTR _dwBytes$[esp+60]
  000d9	50		 push	 eax
  000da	41		 inc	 ecx
  000db	52		 push	 edx
  000dc	89 4e 5c	 mov	 DWORD PTR [esi+92], ecx
  000df	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000e2	53		 push	 ebx
  000e3	51		 push	 ecx
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000ea	85 c0		 test	 eax, eax
  000ec	74 10		 je	 SHORT $L229152
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000f4	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000f9	74 03		 je	 SHORT $L229152

; 189  : 		{
; 190  : 			int nReference	= --m_nReference;

  000fb	ff 4e 5c	 dec	 DWORD PTR [esi+92]
$L229152:

; 191  : #ifdef __INFO_SOCKLIB0516
; 192  : 			m_dwDbgInfo	= err; // * 1000 + 6 * 100 + nReference * 10;
; 193  : #endif	// __INFO_SOCKLIB0516
; 194  : 		}
; 195  : 		
; 196  : 	}
; 197  : 	else

  000fe	8b 5c 24 10	 mov	 ebx, DWORD PTR tv197[esp+48]
$L227603:

; 200  : 	}
; 201  : }

  00102	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__LeaveCriticalSection@4
  00108	55		 push	 ebp
  00109	ff d6		 call	 esi
  0010b	53		 push	 ebx
  0010c	ff d6		 call	 esi
  0010e	5d		 pop	 ebp
  0010f	5f		 pop	 edi
  00110	5b		 pop	 ebx
$L227588:
  00111	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00115	5e		 pop	 esi
  00116	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0011d	83 c4 20	 add	 esp, 32			; 00000020H
  00120	c2 0c 00	 ret	 12			; 0000000cH
$L227596:

; 198  : 	{
; 199  : 		m_lspSendBuffer.AddData( (LPBYTE)lpData, dwDataSize, m_nBufferType );

  00123	8d 4e 60	 lea	 ecx, DWORD PTR [esi+96]
  00126	e8 00 00 00 00	 call	 ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ; CBufferQueue::AddData
  0012b	eb d5		 jmp	 SHORT $L227603
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229096:
  00000	8d 4d e8	 lea	 ecx, DWORD PTR _Lock1$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
$L229097:
  00008	8d 4d ec	 lea	 ecx, DWORD PTR _Lock$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
__ehhandler$?Send@CClientSock@@UAEXPADKK@Z:
  00010	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229151
  00015	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Send@CClientSock@@UAEXPADKK@Z ENDP			; CClientSock::Send
PUBLIC	?SendRemnant@CClientSock@@QAEHK@Z		; CClientSock::SendRemnant
EXTRN	?RemoveData@CBufferQueue@@QAEXK@Z:NEAR		; CBufferQueue::RemoveData
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229212 DD	0ffffffffH
	DD	FLAT:$L229165
$T229210 DD	019930520H
	DD	01H
	DD	FLAT:$T229212
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsock.cpp
xdata$x	ENDS
;	COMDAT ?SendRemnant@CClientSock@@QAEHK@Z
_TEXT	SEGMENT
_dwBufferCount$ = -20					; size = 4
_Lock$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dwBytes$ = 8						; size = 4
?SendRemnant@CClientSock@@QAEHK@Z PROC NEAR		; CClientSock::SendRemnant, COMDAT
; _this$ = ecx

; 224  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SendRemnant@CClientSock@@QAEHK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx

; 225  : 	ASSERT( m_hSocket != INVALID_SOCKET );
; 226  : 	DWORD dwBufferCount;
; 227  : 	
; 228  : 	CMclAutoLock	Lock( m_lspSendBuffer.m_cs );

  0001d	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  00020	57		 push	 edi
  00021	8d 68 04	 lea	 ebp, DWORD PTR [eax+4]
  00024	55		 push	 ebp
  00025	89 44 24 18	 mov	 DWORD PTR _Lock$[esp+40], eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 229  : 
; 230  : 	m_lspSendBuffer.RemoveData( dwBytes );

  0002f	8b 44 24 28	 mov	 eax, DWORD PTR _dwBytes$[esp+32]
  00033	8d 5e 60	 lea	 ebx, DWORD PTR [esi+96]
  00036	50		 push	 eax
  00037	8b cb		 mov	 ecx, ebx
  00039	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+48], 0
  00041	e8 00 00 00 00	 call	 ?RemoveData@CBufferQueue@@QAEXK@Z ; CBufferQueue::RemoveData

; 231  : 	
; 232  : 	if( m_lspSendBuffer.IsEmpty() )

  00046	8b 46 6c	 mov	 eax, DWORD PTR [esi+108]
  00049	85 c0		 test	 eax, eax
  0004b	75 28		 jne	 SHORT $L227626

; 233  : 	{
; 234  : 		if( !m_bDoNotWrite )

  0004d	8b 7e 3c	 mov	 edi, DWORD PTR [esi+60]
  00050	85 ff		 test	 edi, edi
  00052	75 03		 jne	 SHORT $L227627

; 235  : 			m_nReference--;

  00054	ff 4e 5c	 dec	 DWORD PTR [esi+92]
$L227627:

; 236  : 		return m_bDoNotWrite;

  00057	55		 push	 ebp
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0005e	8b c7		 mov	 eax, edi
  00060	5f		 pop	 edi
  00061	5e		 pop	 esi
  00062	5d		 pop	 ebp
  00063	5b		 pop	 ebx

; 249  : }

  00064	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006f	83 c4 14	 add	 esp, 20			; 00000014H
  00072	c2 04 00	 ret	 4
$L227626:

; 237  : 	}
; 238  : 
; 239  : 	m_lspSendBuffer.GetData( m_lpBuffers, &dwBufferCount );

  00075	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwBufferCount$[esp+36]
  00079	51		 push	 ecx
  0007a	8d be 8c 00 00
	00		 lea	 edi, DWORD PTR [esi+140]
  00080	57		 push	 edi
  00081	8b cb		 mov	 ecx, ebx
  00083	e8 00 00 00 00	 call	 ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z ; CBufferQueue::GetData

; 240  : 
; 241  : 	memset( (void*)&m_ovSend, 0, sizeof(WSAOVERLAPPED) );

  00088	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  0008b	33 d2		 xor	 edx, edx
  0008d	8b c8		 mov	 ecx, eax
  0008f	89 11		 mov	 DWORD PTR [ecx], edx
  00091	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00094	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00097	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 242  : 	int err;
; 243  : 	if( WSASend( GetHandle(), m_lpBuffers, dwBufferCount, &dwBytes, 0, &m_ovSend, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  0009a	52		 push	 edx
  0009b	50		 push	 eax
  0009c	8b 44 24 18	 mov	 eax, DWORD PTR _dwBufferCount$[esp+44]
  000a0	52		 push	 edx
  000a1	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  000a4	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  000a7	8d 54 24 34	 lea	 edx, DWORD PTR _dwBytes$[esp+44]
  000ab	52		 push	 edx
  000ac	50		 push	 eax
  000ad	57		 push	 edi
  000ae	56		 push	 esi
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000b5	85 c0		 test	 eax, eax
  000b7	74 2e		 je	 SHORT $L227632
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000bf	8b f0		 mov	 esi, eax
  000c1	81 fe e5 03 00
	00		 cmp	 esi, 997		; 000003e5H
  000c7	74 1e		 je	 SHORT $L227632

; 244  : 	{
; 245  : //		TRACE( "i/O error, close socket %d //REF:%d\n", GetHandle(), m_l-1 );
; 246  : 		return err;

  000c9	55		 push	 ebp
  000ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000d0	5f		 pop	 edi
  000d1	8b c6		 mov	 eax, esi
  000d3	5e		 pop	 esi
  000d4	5d		 pop	 ebp
  000d5	5b		 pop	 ebx

; 249  : }

  000d6	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000da	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000e1	83 c4 14	 add	 esp, 20			; 00000014H
  000e4	c2 04 00	 ret	 4
$L227632:

; 247  : 	}
; 248  : 	return 0;

  000e7	55		 push	 ebp
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 249  : }

  000ee	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  000f2	5f		 pop	 edi
  000f3	5e		 pop	 esi
  000f4	5d		 pop	 ebp
  000f5	33 c0		 xor	 eax, eax
  000f7	5b		 pop	 ebx
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ff	83 c4 14	 add	 esp, 20			; 00000014H
  00102	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229165:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _Lock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
__ehhandler$?SendRemnant@CClientSock@@QAEHK@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229210
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SendRemnant@CClientSock@@QAEHK@Z ENDP			; CClientSock::SendRemnant
; Function compile flags: /Ogty
;	COMDAT ??_GCClientSock@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCClientSock@@UAEPAXI@Z PROC NEAR			; CClientSock::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CClientSock@@UAE@XZ	; CClientSock::~CClientSock
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L229218
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L229218:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCClientSock@@UAEPAXI@Z ENDP				; CClientSock::`scalar deleting destructor'
_TEXT	ENDS
END
