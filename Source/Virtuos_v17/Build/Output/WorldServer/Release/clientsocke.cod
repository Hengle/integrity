; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Network\Net\Src\clientsocke.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHandle@CSock@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCClientSockE@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CClientSockE@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Close@CClientSockE@@UAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CloseConnection@CClientSockE@@UAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Shutdown@CClientSockE@@UAEHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Create@CClientSockE@@UAEHGH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Attach@CClientSockE@@UAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Connect@CClientSockE@@QAEHPADG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Send@CClientSockE@@UAEXPADKK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Recv@CClientSockE@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SendRemnant@CClientSockE@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Fetch@CClientSockE@@QAEPAVCBuffer@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBuffer@CClientSockE@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CClientSockE@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetHandle@CSock@@QAEIXZ			; CSock::GetHandle
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\sock.h
;	COMDAT ?GetHandle@CSock@@QAEIXZ
_TEXT	SEGMENT
?GetHandle@CSock@@QAEIXZ PROC NEAR			; CSock::GetHandle, COMDAT
; _this$ = ecx

; 50   : inline SOCKET CSock::GetHandle( void )	{	return m_hSocket;	}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetHandle@CSock@@QAEIXZ ENDP				; CSock::GetHandle
_TEXT	ENDS
PUBLIC	?GetHeaderLength@CBuffer@@QAEKXZ		; CBuffer::GetHeaderLength
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT
?GetHeaderLength@CBuffer@@QAEKXZ PROC NEAR		; CBuffer::GetHeaderLength, COMDAT
; _this$ = ecx

; 66   : 		return m_dwHeaderSize;

  00000	8b 81 24 20 00
	00		 mov	 eax, DWORD PTR [ecx+8228]

; 67   : 	}

  00006	c3		 ret	 0
?GetHeaderLength@CBuffer@@QAEKXZ ENDP			; CBuffer::GetHeaderLength
_TEXT	ENDS
PUBLIC	?GetSize@CBuffer@@QAEHXZ			; CBuffer::GetSize
; Function compile flags: /Ogty
;	COMDAT ?GetSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT
?GetSize@CBuffer@@QAEHXZ PROC NEAR			; CBuffer::GetSize, COMDAT
; _this$ = ecx

; 99   : 	return (int)( m_lpBufMax - m_lpBufStart );	

  00000	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  00006	2b 81 0c 20 00
	00		 sub	 eax, DWORD PTR [ecx+8204]

; 100  : }

  0000c	c3		 ret	 0
?GetSize@CBuffer@@QAEHXZ ENDP				; CBuffer::GetSize
_TEXT	ENDS
PUBLIC	?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetWritableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetWritableBuffer, COMDAT
; _this$ = ecx

; 104  : 	*pnBufSize	= (int)( m_lpBufMax - m_pTail );	

  00000	8b 91 18 20 00
	00		 mov	 edx, DWORD PTR [ecx+8216]
  00006	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 105  : 	return m_pTail;	

  00014	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]

; 106  : }

  0001a	c2 04 00	 ret	 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetWritableBuffer
_TEXT	ENDS
PUBLIC	?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetReadableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetReadableBuffer, COMDAT
; _this$ = ecx

; 115  : 	*pnBufSize	= (int)( m_pTail - m_pHead );	

  00000	8b 91 14 20 00
	00		 mov	 edx, DWORD PTR [ecx+8212]
  00006	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 116  : 	return m_pHead;	

  00014	8b 81 14 20 00
	00		 mov	 eax, DWORD PTR [ecx+8212]

; 117  : }

  0001a	c2 04 00	 ret	 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetReadableBuffer
_TEXT	ENDS
PUBLIC	?IsEmpty@CBufferQueue@@QAEHXZ			; CBufferQueue::IsEmpty
; Function compile flags: /Ogty
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CBufferQueue@@QAEHXZ PROC NEAR			; CBufferQueue::IsEmpty, COMDAT
; _this$ = ecx

; 222  : 	{	return( m_uCount == 0 );	}

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CBufferQueue@@QAEHXZ ENDP			; CBufferQueue::IsEmpty
_TEXT	ENDS
PUBLIC	??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z		; CClientSockE::CClientSockE
PUBLIC	?Create@CClientSockE@@UAEHGH@Z			; CClientSockE::Create
PUBLIC	?Attach@CClientSockE@@UAEXI@Z			; CClientSockE::Attach
PUBLIC	?Close@CClientSockE@@UAEXXZ			; CClientSockE::Close
PUBLIC	?CloseConnection@CClientSockE@@UAEHI@Z		; CClientSockE::CloseConnection
PUBLIC	?Shutdown@CClientSockE@@UAEHI@Z			; CClientSockE::Shutdown
PUBLIC	?Send@CClientSockE@@UAEXPADKK@Z			; CClientSockE::Send
PUBLIC	?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z	; CClientSockE::GetPeerAddr
PUBLIC	??_7CClientSockE@@6B@				; CClientSockE::`vftable'
PUBLIC	??_GCClientSockE@@UAEPAXI@Z			; CClientSockE::`scalar deleting destructor'
PUBLIC	?GetPeerAddr@CSock@@UAEKK@Z			; CSock::GetPeerAddr
PUBLIC	?Get@CSock@@UAEPAV1@I@Z				; CSock::Get
EXTRN	??0CBufferQueue@@QAE@XZ:NEAR			; CBufferQueue::CBufferQueue
EXTRN	??1CBufferQueue@@UAE@XZ:NEAR			; CBufferQueue::~CBufferQueue
EXTRN	?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z:NEAR ; CBufferFactory::CreateBuffer
EXTRN	?GetInstance@CBufferFactory@@SAAAV1@XZ:NEAR	; CBufferFactory::GetInstance
EXTRN	??_ECClientSockE@@UAEPAXI@Z:NEAR		; CClientSockE::`vector deleting destructor'
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	??0CSock@@QAE@XZ:NEAR				; CSock::CSock
EXTRN	??1CSock@@UAE@XZ:NEAR				; CSock::~CSock
EXTRN	?Detach@CSock@@UAEXXZ:NEAR			; CSock::Detach
EXTRN	?GetHostAddr@CSock@@UAEJPAXPAK@Z:NEAR		; CSock::GetHostAddr
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsocke.cpp
xdata$x	SEGMENT
$T228962 DD	0ffffffffH
	DD	FLAT:$L228954
	DD	00H
	DD	FLAT:$L228955
$T228959 DD	019930520H
	DD	02H
	DD	FLAT:$T228962
	DD	2 DUP(00H)
	DD	2 DUP(00H)
xdata$x	ENDS
;	COMDAT ??_7CClientSockE@@6B@
CONST	SEGMENT
??_7CClientSockE@@6B@ DD FLAT:??_ECClientSockE@@UAEPAXI@Z ; CClientSockE::`vftable'
	DD	FLAT:?Create@CClientSockE@@UAEHGH@Z
	DD	FLAT:?Attach@CClientSockE@@UAEXI@Z
	DD	FLAT:?Detach@CSock@@UAEXXZ
	DD	FLAT:?GetHostAddr@CSock@@UAEJPAXPAK@Z
	DD	FLAT:?GetPeerAddr@CSock@@UAEKK@Z
	DD	FLAT:?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z
	DD	FLAT:?Close@CClientSockE@@UAEXXZ
	DD	FLAT:?CloseConnection@CClientSockE@@UAEHI@Z
	DD	FLAT:?Shutdown@CClientSockE@@UAEHI@Z
	DD	FLAT:?Send@CClientSockE@@UAEXPADKK@Z
	DD	FLAT:?Get@CSock@@UAEPAV1@I@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z PROC NEAR	; CClientSockE::CClientSockE, COMDAT
; _this$ = ecx

; 27   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	57		 push	 edi
  0001a	89 74 24 08	 mov	 DWORD PTR _this$[esp+24], esi
  0001e	e8 00 00 00 00	 call	 ??0CSock@@QAE@XZ	; CSock::CSock
  00023	33 ff		 xor	 edi, edi
  00025	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  00028	89 7c 24 14	 mov	 DWORD PTR __$EHRec$[esp+32], edi
  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CClientSockE@@6B@
  00032	e8 00 00 00 00	 call	 ??0CBufferQueue@@QAE@XZ	; CBufferQueue::CBufferQueue

; 28   : #ifdef __CRC
; 29   : 	m_hRecv		= m_hSend	= WSA_INVALID_EVENT;
; 30   : 	m_hWorker	= (HANDLE)NULL;
; 31   : 	m_l	= 0;
; 32   : 	m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( BUFFER_TYPE_5BYTE );
; 33   : 
; 34   : 	if( CSock::crcRead & dwcrc )
; 35   : 		m_dwReadHeaderSize	= HEADERSIZE13;
; 36   : 	else
; 37   : 		m_dwReadHeaderSize	= HEADERSIZE5;
; 38   : 
; 39   : #ifdef __PROTOCOL0910
; 40   : 	m_dwProtocolId	= 0;
; 41   : #endif	// __PROTOCOL0910
; 42   : 
; 43   : 	if( CSock::crcWrite & dwcrc )
; 44   : #ifdef __PROTOCOL0910
; 45   : 		m_lspSendBuffer.crc( &m_crcWrite, &m_dwProtocolId );
; 46   : #else	// __PROTOCOL0910
; 47   : 		m_lspSendBuffer.crc( &m_crcWrite );
; 48   : #endif	// __PROTOCOL0910
; 49   : 
; 50   : #else	// __CRC
; 51   : 	m_hRecv		= m_hSend	= WSA_INVALID_EVENT;

  00037	89 7e 40	 mov	 DWORD PTR [esi+64], edi
  0003a	89 7e 3c	 mov	 DWORD PTR [esi+60], edi

; 52   : 	m_hWorker	= (HANDLE)NULL;

  0003d	89 7e 44	 mov	 DWORD PTR [esi+68], edi

; 53   : 	m_l	= 0;

  00040	89 7e 48	 mov	 DWORD PTR [esi+72], edi

; 54   : 	m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( type );

  00043	8b 7c 24 1c	 mov	 edi, DWORD PTR _type$[esp+20]
  00047	68 00 20 00 00	 push	 8192			; 00002000H
  0004c	57		 push	 edi
  0004d	c6 44 24 1c 01	 mov	 BYTE PTR __$EHRec$[esp+40], 1
  00052	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00057	8b c8		 mov	 ecx, eax
  00059	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 55   : 
; 56   : 	m_nBufferType = type;
; 57   : 
; 58   : #endif	// __CRC
; 59   : 
; 60   : #ifdef __INFO_SOCKLIB0516
; 61   : 	m_dwDbgInfo		= 0;
; 62   : #endif	// __INFO_SOCKLIB0516
; 63   : }

  0005e	8b 4c 24 0c	 mov	 ecx, DWORD PTR __$EHRec$[esp+24]
  00062	89 be 78 04 00
	00		 mov	 DWORD PTR [esi+1144], edi
  00068	89 46 10	 mov	 DWORD PTR [esi+16], eax
  0006b	5f		 pop	 edi
  0006c	8b c6		 mov	 eax, esi
  0006e	5e		 pop	 esi
  0006f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00076	83 c4 10	 add	 esp, 16			; 00000010H
  00079	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L228954:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CSock@@UAE@XZ	; CSock::~CSock
$L228955:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 4c	 add	 ecx, 76			; 0000004cH
  0000e	e9 00 00 00 00	 jmp	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
__ehhandler$??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z:
  00013	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T228959
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??0CClientSockE@@QAE@W4BUFFER_TYPE@@@Z ENDP		; CClientSockE::CClientSockE
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\sock.h
;	COMDAT ?GetPeerAddr@CSock@@UAEKK@Z
_TEXT	SEGMENT
_dpid$ = 8						; size = 4
?GetPeerAddr@CSock@@UAEKK@Z PROC NEAR			; CSock::GetPeerAddr, COMDAT
; _this$ = ecx

; 37   : 	virtual	DWORD	GetPeerAddr( DPID dpid ) { return 0; }

  00000	33 c0		 xor	 eax, eax
  00002	c2 04 00	 ret	 4
?GetPeerAddr@CSock@@UAEKK@Z ENDP			; CSock::GetPeerAddr
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Get@CSock@@UAEPAV1@I@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Get@CSock@@UAEPAV1@I@Z PROC NEAR			; CSock::Get, COMDAT
; _this$ = ecx

; 51   : inline CSock* CSock::Get( SOCKET hSocket )	{	return( m_hSocket == hSocket ? this : NULL );	}

  00000	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00003	56		 push	 esi
  00004	8b 74 24 08	 mov	 esi, DWORD PTR _hSocket$[esp]
  00008	33 c0		 xor	 eax, eax
  0000a	3b d6		 cmp	 edx, esi
  0000c	0f 95 c0	 setne	 al
  0000f	5e		 pop	 esi
  00010	48		 dec	 eax
  00011	23 c1		 and	 eax, ecx
  00013	c2 04 00	 ret	 4
?Get@CSock@@UAEPAV1@I@Z ENDP				; CSock::Get
_TEXT	ENDS
EXTRN	__imp__closesocket@4:NEAR
EXTRN	__imp__shutdown@8:NEAR
EXTRN	__imp__WSACloseEvent@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsocke.cpp
;	COMDAT ?Close@CClientSockE@@UAEXXZ
_TEXT	SEGMENT
?Close@CClientSockE@@UAEXXZ PROC NEAR			; CClientSockE::Close, COMDAT
; _this$ = ecx

; 71   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 72   : 	CLOSE_SOCKET( m_hSocket );

  00003	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00006	83 f8 ff	 cmp	 eax, -1
  00009	57		 push	 edi
  0000a	74 1a		 je	 SHORT $L227562
  0000c	6a 02		 push	 2
  0000e	50		 push	 eax
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__shutdown@8
  00015	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  0001f	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1
$L227562:

; 73   : 	CLOSE_WSAEVENT( m_hRecv );

  00026	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00029	85 c0		 test	 eax, eax
  0002b	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSACloseEvent@4
  00031	74 0a		 je	 SHORT $L227565
  00033	50		 push	 eax
  00034	ff d7		 call	 edi
  00036	c7 46 3c 00 00
	00 00		 mov	 DWORD PTR [esi+60], 0
$L227565:

; 74   : 	CLOSE_WSAEVENT( m_hSend );

  0003d	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00040	85 c0		 test	 eax, eax
  00042	74 0a		 je	 SHORT $L227568
  00044	50		 push	 eax
  00045	ff d7		 call	 edi
  00047	c7 46 40 00 00
	00 00		 mov	 DWORD PTR [esi+64], 0
$L227568:
  0004e	5f		 pop	 edi
  0004f	5e		 pop	 esi

; 75   : }

  00050	c3		 ret	 0
?Close@CClientSockE@@UAEXXZ ENDP			; CClientSockE::Close
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?CloseConnection@CClientSockE@@UAEHI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?CloseConnection@CClientSockE@@UAEHI@Z PROC NEAR	; CClientSockE::CloseConnection, COMDAT
; _this$ = ecx

; 79   : 	ASSERT( hSocket == m_hSocket );
; 80   : 	Close();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	ff 50 1c	 call	 DWORD PTR [eax+28]

; 81   : 	return( TRUE );

  00005	b8 01 00 00 00	 mov	 eax, 1

; 82   : }

  0000a	c2 04 00	 ret	 4
?CloseConnection@CClientSockE@@UAEHI@Z ENDP		; CClientSockE::CloseConnection
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?Shutdown@CClientSockE@@UAEHI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Shutdown@CClientSockE@@UAEHI@Z PROC NEAR		; CClientSockE::Shutdown, COMDAT
; _this$ = ecx

; 86   : 	return FALSE;

  00000	33 c0		 xor	 eax, eax

; 87   : }

  00002	c2 04 00	 ret	 4
?Shutdown@CClientSockE@@UAEHI@Z ENDP			; CClientSockE::Shutdown
_TEXT	ENDS
EXTRN	__imp__WSACreateEvent@0:NEAR
EXTRN	?Create@CSock@@UAEHGH@Z:NEAR			; CSock::Create
; Function compile flags: /Ogty
;	COMDAT ?Create@CClientSockE@@UAEHGH@Z
_TEXT	SEGMENT
_uPort$ = 8						; size = 2
_type$ = 12						; size = 4
?Create@CClientSockE@@UAEHGH@Z PROC NEAR		; CClientSockE::Create, COMDAT
; _this$ = ecx

; 97   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 98   : 	if( m_hRecv == WSA_INVALID_EVENT )

  00003	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  00006	85 c0		 test	 eax, eax
  00008	57		 push	 edi
  00009	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSACreateEvent@0
  0000f	75 05		 jne	 SHORT $L227585

; 99   : 		m_hRecv		= WSACreateEvent();

  00011	ff d7		 call	 edi
  00013	89 46 3c	 mov	 DWORD PTR [esi+60], eax
$L227585:

; 100  : 	if( m_hSend == WSA_INVALID_EVENT )

  00016	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  00019	85 c0		 test	 eax, eax
  0001b	75 05		 jne	 SHORT $L227587

; 101  : 		m_hSend		= WSACreateEvent();

  0001d	ff d7		 call	 edi
  0001f	89 46 40	 mov	 DWORD PTR [esi+64], eax
$L227587:

; 102  : 	
; 103  : 	return CSock::Create( uPort, type );

  00022	8b 44 24 10	 mov	 eax, DWORD PTR _type$[esp+4]
  00026	8b 4c 24 0c	 mov	 ecx, DWORD PTR _uPort$[esp+4]
  0002a	50		 push	 eax
  0002b	51		 push	 ecx
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?Create@CSock@@UAEHGH@Z	; CSock::Create
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 104  : }

  00035	c2 08 00	 ret	 8
?Create@CClientSockE@@UAEHGH@Z ENDP			; CClientSockE::Create
_TEXT	ENDS
EXTRN	?Clear@CSock@@QAEXXZ:NEAR			; CSock::Clear
EXTRN	?Attach@CSock@@UAEXI@Z:NEAR			; CSock::Attach
; Function compile flags: /Ogty
;	COMDAT ?Attach@CClientSockE@@UAEXI@Z
_TEXT	SEGMENT
_hSocket$ = 8						; size = 4
?Attach@CClientSockE@@UAEXI@Z PROC NEAR			; CClientSockE::Attach, COMDAT
; _this$ = ecx

; 107  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 108  : 	Clear();

  00004	e8 00 00 00 00	 call	 ?Clear@CSock@@QAEXXZ	; CSock::Clear

; 109  : 
; 110  : 	if( m_hRecv == WSA_INVALID_EVENT )

  00009	8b 46 3c	 mov	 eax, DWORD PTR [esi+60]
  0000c	85 c0		 test	 eax, eax
  0000e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__WSACreateEvent@0
  00014	75 05		 jne	 SHORT $L227593

; 111  : 		m_hRecv		= WSACreateEvent();

  00016	ff d7		 call	 edi
  00018	89 46 3c	 mov	 DWORD PTR [esi+60], eax
$L227593:

; 112  : 	if( m_hSend == WSA_INVALID_EVENT )

  0001b	8b 46 40	 mov	 eax, DWORD PTR [esi+64]
  0001e	85 c0		 test	 eax, eax
  00020	75 05		 jne	 SHORT $L227595

; 113  : 		m_hSend		= WSACreateEvent();

  00022	ff d7		 call	 edi
  00024	89 46 40	 mov	 DWORD PTR [esi+64], eax
$L227595:

; 114  : 
; 115  : 	CSock::Attach( hSocket );

  00027	8b 44 24 0c	 mov	 eax, DWORD PTR _hSocket$[esp+4]
  0002b	50		 push	 eax
  0002c	8b ce		 mov	 ecx, esi
  0002e	e8 00 00 00 00	 call	 ?Attach@CSock@@UAEXI@Z	; CSock::Attach
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi

; 116  : }

  00035	c2 04 00	 ret	 4
?Attach@CClientSockE@@UAEXI@Z ENDP			; CClientSockE::Attach
_TEXT	ENDS
PUBLIC	?Connect@CClientSockE@@QAEHPADG@Z		; CClientSockE::Connect
EXTRN	__imp__connect@12:NEAR
EXTRN	__imp__htons@4:NEAR
EXTRN	__imp__inet_addr@4:NEAR
EXTRN	__imp__gethostbyname@4:NEAR
EXTRN	__imp__WSASetLastError@4:NEAR
EXTRN	__imp__WSAGetLastError@0:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Connect@CClientSockE@@QAEHPADG@Z
_TEXT	SEGMENT
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_lpAddr$ = 8						; size = 4
_uPort$ = 12						; size = 2
?Connect@CClientSockE@@QAEHPADG@Z PROC NEAR		; CClientSockE::Connect, COMDAT
; _this$ = ecx

; 119  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00008	33 c4		 xor	 eax, esp
  0000a	56		 push	 esi
  0000b	8b 74 24 1c	 mov	 esi, DWORD PTR _lpAddr$[esp+20]
  0000f	57		 push	 edi
  00010	8b f9		 mov	 edi, ecx
  00012	89 44 24 18	 mov	 DWORD PTR __$ArrayPad$[esp+28], eax

; 120  : 	if( m_hSocket == INVALID_SOCKET )

  00016	83 7f 04 ff	 cmp	 DWORD PTR [edi+4], -1

; 121  : 	{
; 122  : 		TRACE( "Creation needed\n" );
; 123  : 		return FALSE;

  0001a	0f 84 93 00 00
	00		 je	 $L228996

; 124  : 	}
; 125  : 
; 126  : 	SOCKADDR_IN sin;
; 127  : 	memset( &sin, 0, sizeof(sin) );

  00020	33 c0		 xor	 eax, eax
  00022	89 44 24 08	 mov	 DWORD PTR _sin$[esp+28], eax
  00026	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
  0002a	89 44 24 10	 mov	 DWORD PTR _sin$[esp+36], eax

; 128  : 	sin.sin_family	= AF_INET;
; 129  : 	sin.sin_addr.s_addr		= inet_addr( lpAddr );

  0002e	56		 push	 esi
  0002f	89 44 24 18	 mov	 DWORD PTR _sin$[esp+44], eax
  00033	66 c7 44 24 0c
	02 00		 mov	 WORD PTR _sin$[esp+32], 2
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4

; 130  : 
; 131  : 	if( sin.sin_addr.s_addr == INADDR_NONE )

  00040	83 f8 ff	 cmp	 eax, -1
  00043	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
  00047	75 16		 jne	 SHORT $L227608

; 132  : 	{
; 133  : 		LPHOSTENT lphost;
; 134  : 		lphost	= gethostbyname( lpAddr );

  00049	56		 push	 esi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__gethostbyname@4

; 135  : 		if( lphost )

  00050	85 c0		 test	 eax, eax
  00052	74 54		 je	 SHORT $L227606

; 136  : 			sin.sin_addr.s_addr		= ((LPIN_ADDR)lphost->h_addr)->s_addr;

  00054	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 02		 mov	 eax, DWORD PTR [edx]
  0005b	89 44 24 0c	 mov	 DWORD PTR _sin$[esp+32], eax
$L227608:

; 145  : 		}
; 146  : 	}
; 147  : 
; 148  : 	sin.sin_port = htons( uPort );

  0005f	8b 4c 24 24	 mov	 ecx, DWORD PTR _uPort$[esp+24]
  00063	51		 push	 ecx
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4

; 149  : 
; 150  : 	if( connect( m_hSocket, (LPSOCKADDR) &sin, sizeof(sin) ) == SOCKET_ERROR )

  0006a	6a 10		 push	 16			; 00000010H
  0006c	8d 54 24 0c	 lea	 edx, DWORD PTR _sin$[esp+32]
  00070	66 89 44 24 0e	 mov	 WORD PTR _sin$[esp+34], ax
  00075	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  00078	52		 push	 edx
  00079	50		 push	 eax
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__connect@12
  00080	83 f8 ff	 cmp	 eax, -1
  00083	75 43		 jne	 SHORT $L227610

; 151  : 	{
; 152  : 		int	err;
; 153  : 		if( ( err = WSAGetLastError() ) == WSAEWOULDBLOCK )

  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  0008b	2d 33 27 00 00	 sub	 eax, 10035		; 00002733H
  00090	f7 d8		 neg	 eax
  00092	1b c0		 sbb	 eax, eax
  00094	5f		 pop	 edi
  00095	40		 inc	 eax
  00096	5e		 pop	 esi

; 154  : 			return TRUE;
; 155  : 		#ifdef __INFO_SOCKLIB0516
; 156  : 			m_dwDbgInfo = err;
; 157  : 		#endif
; 158  : 		TRACE( "Can't connect with error %d\n", err );
; 159  : 		return FALSE;
; 160  : 	}
; 161  : 	return TRUE;
; 162  : }

  00097	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  0009b	33 cc		 xor	 ecx, esp
  0009d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a2	83 c4 14	 add	 esp, 20			; 00000014H
  000a5	c2 08 00	 ret	 8
$L227606:

; 137  : 		else
; 138  : 		{
; 139  : 			#ifdef __INFO_SOCKLIB0516
; 140  : 				m_dwDbgInfo = WSAEINVAL;
; 141  : 			#endif
; 142  : 
; 143  : 			WSASetLastError( WSAEINVAL );

  000a8	68 26 27 00 00	 push	 10022			; 00002726H
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASetLastError@4
$L228996:
  000b3	5f		 pop	 edi

; 144  : 			return FALSE;

  000b4	33 c0		 xor	 eax, eax
  000b6	5e		 pop	 esi

; 154  : 			return TRUE;
; 155  : 		#ifdef __INFO_SOCKLIB0516
; 156  : 			m_dwDbgInfo = err;
; 157  : 		#endif
; 158  : 		TRACE( "Can't connect with error %d\n", err );
; 159  : 		return FALSE;
; 160  : 	}
; 161  : 	return TRUE;
; 162  : }

  000b7	8b 4c 24 10	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+20]
  000bb	33 cc		 xor	 ecx, esp
  000bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c2	83 c4 14	 add	 esp, 20			; 00000014H
  000c5	c2 08 00	 ret	 8
$L227610:
  000c8	8b 4c 24 18	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+28]
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	33 cc		 xor	 ecx, esp
  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000da	83 c4 14	 add	 esp, 20			; 00000014H
  000dd	c2 08 00	 ret	 8
?Connect@CClientSockE@@QAEHPADG@Z ENDP			; CClientSockE::Connect
_TEXT	ENDS
PUBLIC	?Recv@CClientSockE@@QAEHXZ			; CClientSockE::Recv
EXTRN	__imp__InterlockedDecrement@4:NEAR
EXTRN	__imp__WSARecv@28:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Recv@CClientSockE@@QAEHXZ
_TEXT	SEGMENT
_dwFlags$ = -16						; size = 4
_dwBytesRecvd$ = -12					; size = 4
_buffer$ = -8						; size = 8
?Recv@CClientSockE@@QAEHXZ PROC NEAR			; CClientSockE::Recv, COMDAT
; _this$ = ecx

; 193  : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 194  : 	ASSERT( m_hSocket != INVALID_SOCKET );
; 195  : 	DWORD dwBytesRecvd, dwFlags	= 0;
; 196  : 
; 197  : 	WSABUF buffer;
; 198  : 	buffer.buf	= (char*)m_pRecvBuffer->GetWritableBuffer( (int*)&buffer.len );

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR _dwFlags$[esp+20], 0
  00011	8b 90 18 20 00
	00		 mov	 edx, DWORD PTR [eax+8216]
  00017	8b 88 10 20 00
	00		 mov	 ecx, DWORD PTR [eax+8208]
  0001d	2b ca		 sub	 ecx, edx
  0001f	89 4c 24 0c	 mov	 DWORD PTR _buffer$[esp+20], ecx
  00023	8b 90 18 20 00
	00		 mov	 edx, DWORD PTR [eax+8216]
  00029	89 54 24 10	 mov	 DWORD PTR _buffer$[esp+24], edx

; 199  : 
; 200  : 	memset( (void*)&m_ovRecv, 0, sizeof(WSAOVERLAPPED) );

  0002d	33 c9		 xor	 ecx, ecx
  0002f	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00032	8b d0		 mov	 edx, eax
  00034	89 0a		 mov	 DWORD PTR [edx], ecx
  00036	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00039	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0003c	57		 push	 edi
  0003d	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 201  : 	m_ovRecv.hEvent		= m_hRecv;
; 202  : 
; 203  : 	int err;
; 204  : 	if( WSARecv( GetHandle(), &buffer, (DWORD)1, &dwBytesRecvd, &dwFlags, &m_ovRecv, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  00040	6a 00		 push	 0
  00042	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00045	8b 4e 3c	 mov	 ecx, DWORD PTR [esi+60]
  00048	50		 push	 eax
  00049	8d 54 24 10	 lea	 edx, DWORD PTR _dwFlags$[esp+32]
  0004d	52		 push	 edx
  0004e	8d 44 24 18	 lea	 eax, DWORD PTR _dwBytesRecvd$[esp+36]
  00052	50		 push	 eax
  00053	6a 01		 push	 1
  00055	8d 54 24 24	 lea	 edx, DWORD PTR _buffer$[esp+44]
  00059	89 4e 24	 mov	 DWORD PTR [esi+36], ecx
  0005c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0005f	52		 push	 edx
  00060	51		 push	 ecx
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSARecv@28
  00067	85 c0		 test	 eax, eax
  00069	74 22		 je	 SHORT $L227645
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00071	8b f8		 mov	 edi, eax
  00073	81 ff e5 03 00
	00		 cmp	 edi, 997		; 000003e5H
  00079	74 12		 je	 SHORT $L227645

; 205  : 	{
; 206  : 		TRACE( "I/o error, close socket %d, %x //REF:%d\n", GetHandle(), this, m_l-1 );
; 207  : 		InterlockedDecrement( &m_l );

  0007b	83 c6 48	 add	 esi, 72			; 00000048H
  0007e	56		 push	 esi
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 208  : 		return err;

  00085	8b c7		 mov	 eax, edi
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 211  : }

  00089	83 c4 10	 add	 esp, 16			; 00000010H
  0008c	c3		 ret	 0
$L227645:
  0008d	5f		 pop	 edi

; 209  : 	}
; 210  : 	return 0;

  0008e	33 c0		 xor	 eax, eax
  00090	5e		 pop	 esi

; 211  : }

  00091	83 c4 10	 add	 esp, 16			; 00000010H
  00094	c3		 ret	 0
?Recv@CClientSockE@@QAEHXZ ENDP				; CClientSockE::Recv
_TEXT	ENDS
PUBLIC	?Fetch@CClientSockE@@QAEPAVCBuffer@@K@Z		; CClientSockE::Fetch
; Function compile flags: /Ogty
;	COMDAT ?Fetch@CClientSockE@@QAEPAVCBuffer@@K@Z
_TEXT	SEGMENT
_pOld$ = 8						; size = 4
_dwBytes$ = 8						; size = 4
?Fetch@CClientSockE@@QAEPAVCBuffer@@K@Z PROC NEAR	; CClientSockE::Fetch, COMDAT
; _this$ = ecx

; 241  : {

  00000	53		 push	 ebx
  00001	8b d9		 mov	 ebx, ecx

; 242  : 	m_pRecvBuffer->m_pTail	+=	dwBytes;

  00003	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00006	8b 4c 24 08	 mov	 ecx, DWORD PTR _dwBytes$[esp]
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	01 88 18 20 00
	00		 add	 DWORD PTR [eax+8216], ecx

; 243  : 	ASSERT( m_pRecvBuffer->m_pTail <= m_pRecvBuffer->m_lpBufMax );
; 244  : 	
; 245  : 	int nRemnant;
; 246  : 	LPBYTE ptr	= m_pRecvBuffer->GetReadableBuffer( &nRemnant );

  00012	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00015	8b b0 14 20 00
	00		 mov	 esi, DWORD PTR [eax+8212]
  0001b	8b a8 18 20 00
	00		 mov	 ebp, DWORD PTR [eax+8216]

; 247  : 
; 248  : 	CBuffer* pOld	= NULL;
; 249  : 	u_long uPacketSize;
; 250  : 
; 251  : #ifdef __CRC
; 252  : 	DWORD dwCrc, dwDataSize;
; 253  : 	byte digest[4];
; 254  : #endif	// __CRC
; 255  : 
; 256  : 	while( 1 )
; 257  : 	{
; 258  : #ifdef __CRC
; 259  : 		if( nRemnant < (int)( m_dwReadHeaderSize ) )
; 260  : #else	// __CRC
; 261  : 		if( nRemnant < (int)( m_pRecvBuffer->GetHeaderLength() ) )

  00021	8b 88 24 20 00
	00		 mov	 ecx, DWORD PTR [eax+8228]
  00027	2b ee		 sub	 ebp, esi
  00029	3b e9		 cmp	 ebp, ecx
  0002b	57		 push	 edi
  0002c	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR _pOld$[esp+12], 0
  00034	7c 34		 jl	 SHORT $L229030
  00036	eb 08 8d a4 24
	00 00 00 00 90	 npad	 10
$L227671:

; 274  : 		}
; 275  : 		else
; 276  : 		{
; 277  : #ifdef __CRC
; 278  : 			if( m_dwReadHeaderSize == HEADERSIZE13 )
; 279  : 			{
; 280  : 				dwCrc	= *(UNALIGNED LPDWORD)( ptr + sizeof(char) );
; 281  : 				dwDataSize	= *(UNALIGNED LPDWORD)( ptr + sizeof(char) + sizeof(DWORD) );
; 282  : 				m_crcRead.Restart();
; 283  : 				m_crcRead.Update( (const byte*)( &dwDataSize ), sizeof(DWORD) );
; 284  : 				m_crcRead.Final( digest );
; 285  : #ifdef __PROTOCOL0910
; 286  : #ifdef __PROTOCOL1021
; 287  : 				if( ~( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 288  : #else	// __PROTOCOL1021
; 289  : 				if( ( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 290  : #endif	// __PROTOCOL1021
; 291  : #else	// __PROTOCOL0910
; 292  : 				if( *(UNALIGNED LPDWORD)digest != dwCrc )
; 293  : #endif	// __PROTOCOL0910
; 294  : 				{
; 295  : 					WSASetLastError( ERROR_BAD_NET_NAME );
; 296  : 					return NULL;
; 297  : 				}
; 298  : 				dwCrc	= *(UNALIGNED LPDWORD)( ptr + sizeof(char) + sizeof(DWORD) + sizeof(DWORD) );
; 299  : 				uPacketSize		= m_dwReadHeaderSize + dwDataSize;
; 300  : 			}
; 301  : 			else
; 302  : 			{
; 303  : 				uPacketSize	= m_dwReadHeaderSize + *(UNALIGNED LPDWORD)&ptr[1];
; 304  : 			}
; 305  : #else	// __CRC
; 306  : 			uPacketSize	= m_pRecvBuffer->GetHeaderLength() + m_pRecvBuffer->GetPacketSize( ptr );

  00040	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	8b b9 24 20 00
	00		 mov	 edi, DWORD PTR [ecx+8228]
  0004b	56		 push	 esi
  0004c	ff 52 04	 call	 DWORD PTR [edx+4]

; 332  : 			}
; 333  : 			else	// completion
; 334  : 			{
; 335  : #ifdef __CRC
; 336  : 				if( m_dwReadHeaderSize == HEADERSIZE13 )
; 337  : 				{
; 338  : 					m_crcRead.Restart();
; 339  : 					m_crcRead.Update( (const byte*)( ptr + m_dwReadHeaderSize ), dwDataSize );
; 340  : 					m_crcRead.Final( digest );
; 341  : #ifdef __PROTOCOL0910
; 342  : #ifdef __PROTOCOL1021
; 343  : 					if( ~( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 344  : #else	// __PROTOCOL1021
; 345  : 					if( ( *(UNALIGNED LPDWORD)digest ^ m_dwProtocolId ) != dwCrc )
; 346  : #endif	// __PROTOCOL1021
; 347  : #else	// __PROTOCOL0910
; 348  : 					if( *(UNALIGNED LPDWORD)digest != dwCrc )
; 349  : #endif	// __PROTOCOL0910
; 350  : 					{
; 351  : 						WSASetLastError( ERROR_BAD_NET_NAME );
; 352  : 						return NULL;
; 353  : 					}
; 354  : 				}
; 355  : #endif	// __CRC
; 356  : 				m_pRecvBuffer->cb++;

  0004f	8b 4b 10	 mov	 ecx, DWORD PTR [ebx+16]
  00052	03 c7		 add	 eax, edi
  00054	3b e8		 cmp	 ebp, eax
  00056	7c 58		 jl	 SHORT $L229031
  00058	ff 41 08	 inc	 DWORD PTR [ecx+8]

; 357  : 				nRemnant	-= ( uPacketSize );

  0005b	2b e8		 sub	 ebp, eax

; 358  : 				ptr		+= ( uPacketSize );

  0005d	03 f0		 add	 esi, eax
  0005f	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00062	3b a8 24 20 00
	00		 cmp	 ebp, DWORD PTR [eax+8228]
  00068	7d d6		 jge	 SHORT $L227671
$L229030:

; 262  : #endif	// __CRC
; 263  : 		{
; 264  : 			if( m_pRecvBuffer->cb > 0 ) {

  0006a	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  0006d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00070	85 c9		 test	 ecx, ecx
  00072	0f 86 a6 00 00
	00		 jbe	 $L229032

; 265  : 				pOld	= m_pRecvBuffer;
; 266  : 				pOld->m_pTail	-= nRemnant;	// remove remnant from old buffer

  00078	29 a8 18 20 00
	00		 sub	 DWORD PTR [eax+8216], ebp

; 267  : 				m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( m_nBufferType );

  0007e	8b 8b 78 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1144]
  00084	68 00 20 00 00	 push	 8192			; 00002000H
  00089	51		 push	 ecx
  0008a	89 44 24 1c	 mov	 DWORD PTR _pOld$[esp+20], eax
  0008e	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00093	8b c8		 mov	 ecx, eax
  00095	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 268  : 				ASSERT( m_pRecvBuffer->m_pTail + nRemnant <= m_pRecvBuffer->m_lpBufMax ); 
; 269  : 				memcpy( m_pRecvBuffer->m_pTail, ptr, nRemnant );

  0009a	8b cd		 mov	 ecx, ebp
  0009c	8b d1		 mov	 edx, ecx
  0009e	89 43 10	 mov	 DWORD PTR [ebx+16], eax
  000a1	8b b8 18 20 00
	00		 mov	 edi, DWORD PTR [eax+8216]
  000a7	c1 e9 02	 shr	 ecx, 2
  000aa	f3 a5		 rep movsd
  000ac	8b ca		 mov	 ecx, edx

; 270  : 
; 271  : 				m_pRecvBuffer->m_pTail	+=	nRemnant;
; 272  : 			}
; 273  : 			return pOld;

  000ae	eb 60		 jmp	 SHORT $L229033
$L229031:

; 307  : #endif	// __CRC
; 308  : 			if( nRemnant < (int)( uPacketSize ) )
; 309  : 			{
; 310  : 				if( (int)( uPacketSize ) > m_pRecvBuffer->GetSize() )

  000b0	8b 91 10 20 00
	00		 mov	 edx, DWORD PTR [ecx+8208]
  000b6	2b 91 0c 20 00
	00		 sub	 edx, DWORD PTR [ecx+8204]
  000bc	3b c2		 cmp	 eax, edx
  000be	7e 0e		 jle	 SHORT $L227681

; 311  : 				{
; 312  : 					pOld	= m_pRecvBuffer;
; 313  : 					m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( m_nBufferType, uPacketSize );

  000c0	50		 push	 eax
  000c1	8b 83 78 04 00
	00		 mov	 eax, DWORD PTR [ebx+1144]
  000c7	89 4c 24 18	 mov	 DWORD PTR _pOld$[esp+16], ecx
  000cb	50		 push	 eax

; 314  : 				}
; 315  : 				else

  000cc	eb 17		 jmp	 SHORT $L229034
$L227681:

; 316  : 				{
; 317  : 					if( m_pRecvBuffer->cb > 0 )

  000ce	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  000d1	85 c0		 test	 eax, eax
  000d3	76 49		 jbe	 SHORT $L229032

; 318  : 					{
; 319  : 						pOld	= m_pRecvBuffer;

  000d5	89 4c 24 14	 mov	 DWORD PTR _pOld$[esp+12], ecx

; 320  : 						m_pRecvBuffer	= CBufferFactory::GetInstance().CreateBuffer( m_nBufferType );

  000d9	8b 8b 78 04 00
	00		 mov	 ecx, DWORD PTR [ebx+1144]
  000df	68 00 20 00 00	 push	 8192			; 00002000H
  000e4	51		 push	 ecx
$L229034:
  000e5	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  000ea	8b c8		 mov	 ecx, eax
  000ec	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer
  000f1	89 43 10	 mov	 DWORD PTR [ebx+16], eax

; 321  : 					}
; 322  : 				}
; 323  : 
; 324  : 				if( pOld )

  000f4	8b 44 24 14	 mov	 eax, DWORD PTR _pOld$[esp+12]
  000f8	85 c0		 test	 eax, eax
  000fa	74 22		 je	 SHORT $L229032

; 325  : 				{
; 326  : 					ASSERT( m_pRecvBuffer->m_pTail + nRemnant <= m_pRecvBuffer->m_lpBufMax );
; 327  : 					memcpy( m_pRecvBuffer->m_pTail, ptr, nRemnant );

  000fc	8b 53 10	 mov	 edx, DWORD PTR [ebx+16]
  000ff	8b ba 18 20 00
	00		 mov	 edi, DWORD PTR [edx+8216]
  00105	8b cd		 mov	 ecx, ebp
  00107	8b c1		 mov	 eax, ecx
  00109	c1 e9 02	 shr	 ecx, 2
  0010c	f3 a5		 rep movsd
  0010e	8b c8		 mov	 ecx, eax
$L229033:
  00110	83 e1 03	 and	 ecx, 3
  00113	f3 a4		 rep movsb

; 328  : 					m_pRecvBuffer->m_pTail	+=	nRemnant;

  00115	8b 5b 10	 mov	 ebx, DWORD PTR [ebx+16]
  00118	01 ab 18 20 00
	00		 add	 DWORD PTR [ebx+8216], ebp
$L229032:

; 329  : 				}
; 330  : 
; 331  : 				return pOld;

  0011e	8b 44 24 14	 mov	 eax, DWORD PTR _pOld$[esp+12]
  00122	5f		 pop	 edi
  00123	5e		 pop	 esi
  00124	5d		 pop	 ebp
  00125	5b		 pop	 ebx

; 359  : 			}
; 360  : 		}
; 361  : 	}
; 362  : 
; 363  : 	return NULL;
; 364  : }

  00126	c2 04 00	 ret	 4
?Fetch@CClientSockE@@QAEPAVCBuffer@@K@Z ENDP		; CClientSockE::Fetch
_TEXT	ENDS
PUBLIC	??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ ; `string'
EXTRN	__imp__getpeername@12:NEAR
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
CONST	SEGMENT
??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@ DB '%d.%d.%d.%d', 00H ; `string'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z
_TEXT	SEGMENT
_namelen$ = -24						; size = 4
_sin$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_dpidPlayer$ = 8					; size = 4
_lpAddr$ = 12						; size = 4
_lpdwSize$ = 16						; size = 4
?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z PROC NEAR	; CClientSockE::GetPeerAddr, COMDAT
; _this$ = ecx

; 367  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H
  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 368  : 	ASSERT( lpAddr );
; 369  : 
; 370  : 	SOCKADDR_IN sin;
; 371  : 	ZeroMemory( &sin, sizeof( SOCKADDR_IN) );
; 372  : 
; 373  : 	int namelen	= sizeof(sin);
; 374  : 	if( getpeername( m_hSocket, (SOCKADDR *)&sin, &namelen ) == SOCKET_ERROR )

  00008	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  0000b	33 c4		 xor	 eax, esp
  0000d	89 44 24 14	 mov	 DWORD PTR __$ArrayPad$[esp+24], eax
  00011	33 c0		 xor	 eax, eax
  00013	89 44 24 04	 mov	 DWORD PTR _sin$[esp+24], eax
  00017	89 44 24 08	 mov	 DWORD PTR _sin$[esp+28], eax
  0001b	56		 push	 esi
  0001c	8b 74 24 24	 mov	 esi, DWORD PTR _lpAddr$[esp+24]
  00020	89 44 24 10	 mov	 DWORD PTR _sin$[esp+36], eax
  00024	8d 54 24 04	 lea	 edx, DWORD PTR _namelen$[esp+28]
  00028	89 44 24 14	 mov	 DWORD PTR _sin$[esp+40], eax
  0002c	52		 push	 edx
  0002d	8d 44 24 0c	 lea	 eax, DWORD PTR _sin$[esp+32]
  00031	50		 push	 eax
  00032	51		 push	 ecx
  00033	c7 44 24 10 10
	00 00 00	 mov	 DWORD PTR _namelen$[esp+40], 16 ; 00000010H
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getpeername@12
  00041	83 f8 ff	 cmp	 eax, -1
  00044	75 17		 jne	 SHORT $L227698

; 375  : 		return DPERR_GENERIC;

  00046	b8 05 40 00 80	 mov	 eax, -2147467259	; 80004005H
  0004b	5e		 pop	 esi

; 381  : 	return DP_OK;
; 382  : }

  0004c	8b 4c 24 14	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+24]
  00050	33 cc		 xor	 ecx, esp
  00052	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00057	83 c4 18	 add	 esp, 24			; 00000018H
  0005a	c2 0c 00	 ret	 12			; 0000000cH
$L227698:

; 376  : 
; 377  : 	sprintf( (char *)lpAddr, "%d.%d.%d.%d", sin.sin_addr.s_net
; 378  : 																	, sin.sin_addr.s_host
; 379  : 																	, sin.sin_addr.s_lh
; 380  : 																	, sin.sin_addr.s_impno );

  0005d	0f b6 54 24 0f	 movzx	 edx, BYTE PTR _sin$[esp+35]
  00062	0f b6 44 24 0e	 movzx	 eax, BYTE PTR _sin$[esp+34]
  00067	52		 push	 edx
  00068	50		 push	 eax
  00069	8b 44 24 14	 mov	 eax, DWORD PTR _sin$[esp+40]
  0006d	0f b6 cc	 movzx	 ecx, ah
  00070	51		 push	 ecx
  00071	0f b6 d0	 movzx	 edx, al
  00074	52		 push	 edx
  00075	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0M@PCENNPGA@?$CFd?4?$CFd?4?$CFd?4?$CFd?$AA@
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 _sprintf

; 381  : 	return DP_OK;
; 382  : }

  00080	8b 4c 24 30	 mov	 ecx, DWORD PTR __$ArrayPad$[esp+52]
  00084	83 c4 18	 add	 esp, 24			; 00000018H
  00087	5e		 pop	 esi
  00088	33 cc		 xor	 ecx, esp
  0008a	33 c0		 xor	 eax, eax
  0008c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00091	83 c4 18	 add	 esp, 24			; 00000018H
  00094	c2 0c 00	 ret	 12			; 0000000cH
?GetPeerAddr@CClientSockE@@UAEJKPAXPAK@Z ENDP		; CClientSockE::GetPeerAddr
_TEXT	ENDS
PUBLIC	?CreateBuffer@CClientSockE@@QAEPAVCBuffer@@XZ	; CClientSockE::CreateBuffer
; Function compile flags: /Ogty
;	COMDAT ?CreateBuffer@CClientSockE@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT
?CreateBuffer@CClientSockE@@QAEPAVCBuffer@@XZ PROC NEAR	; CClientSockE::CreateBuffer, COMDAT
; _this$ = ecx

; 386  : 	return CBufferFactory::GetInstance().CreateBuffer( m_nBufferType );

  00000	8b 81 78 04 00
	00		 mov	 eax, DWORD PTR [ecx+1144]
  00006	68 00 20 00 00	 push	 8192			; 00002000H
  0000b	50		 push	 eax
  0000c	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00011	8b c8		 mov	 ecx, eax
  00013	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 387  : }

  00018	c3		 ret	 0
?CreateBuffer@CClientSockE@@QAEPAVCBuffer@@XZ ENDP	; CClientSockE::CreateBuffer
_TEXT	ENDS
PUBLIC	?Enter@CMclCritSec@@QAEXXZ			; CMclCritSec::Enter
EXTRN	__imp__EnterCriticalSection@4:NEAR
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Enter@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Enter, COMDAT
; _this$ = ecx

; 33   : 		::EnterCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 34   : 	}

  0000a	c3		 ret	 0
?Enter@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Enter
_TEXT	ENDS
PUBLIC	?Leave@CMclCritSec@@QAEXXZ			; CMclCritSec::Leave
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Leave@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Leave, COMDAT
; _this$ = ecx

; 39   : 		::LeaveCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 40   : 	}

  0000a	c3		 ret	 0
?Leave@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Leave
_TEXT	ENDS
PUBLIC	??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z		; CMclAutoLock::CMclAutoLock
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclautolock.h
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT
_rCMclCritSec$ = 8					; size = 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z PROC NEAR	; CMclAutoLock::CMclAutoLock, COMDAT
; _this$ = ecx

; 20   : 	{
; 21   : 		m_pcCritSec = &rCMclCritSec;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _rCMclCritSec$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 22   : 		m_pcCritSec->Enter();

  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 23   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z ENDP		; CMclAutoLock::CMclAutoLock
_TEXT	ENDS
PUBLIC	??1CMclAutoLock@@QAE@XZ				; CMclAutoLock::~CMclAutoLock
; Function compile flags: /Ogty
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT
??1CMclAutoLock@@QAE@XZ PROC NEAR			; CMclAutoLock::~CMclAutoLock, COMDAT
; _this$ = ecx

; 28   : 		m_pcCritSec->Leave();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4
  00005	50		 push	 eax
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 29   : 	}

  0000c	c3		 ret	 0
??1CMclAutoLock@@QAE@XZ ENDP				; CMclAutoLock::~CMclAutoLock
_TEXT	ENDS
PUBLIC	??1CClientSockE@@UAE@XZ				; CClientSockE::~CClientSockE
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsocke.cpp
xdata$x	SEGMENT
$T229073 DD	0ffffffffH
	DD	FLAT:$L229068
$T229071 DD	019930520H
	DD	01H
	DD	FLAT:$T229073
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT ??1CClientSockE@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CClientSockE@@UAE@XZ PROC NEAR			; CClientSockE::~CClientSockE, COMDAT
; _this$ = ecx

; 66   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1CClientSockE@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CClientSockE@@6B@
  00023	c7 44 24 10 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+28], 0

; 67   : 	Close();

  0002b	e8 00 00 00 00	 call	 ?Close@CClientSockE@@UAEXXZ ; CClientSockE::Close

; 68   : }

  00030	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  00033	e8 00 00 00 00	 call	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
  00038	8b ce		 mov	 ecx, esi
  0003a	c7 44 24 10 ff
	ff ff ff	 mov	 DWORD PTR __$EHRec$[esp+28], -1
  00042	e8 00 00 00 00	 call	 ??1CSock@@UAE@XZ	; CSock::~CSock
  00047	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  0004b	5e		 pop	 esi
  0004c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229068:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CSock@@UAE@XZ	; CSock::~CSock
__ehhandler$??1CClientSockE@@UAE@XZ:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229071
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CClientSockE@@UAE@XZ ENDP				; CClientSockE::~CClientSockE
EXTRN	?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z:NEAR ; CBufferQueue::AddData
EXTRN	?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z:NEAR ; CBufferQueue::GetData
EXTRN	__imp__InterlockedIncrement@4:NEAR
EXTRN	__imp__WSASend@28:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229109 DD	0ffffffffH
	DD	FLAT:$L229079
$T229106 DD	019930520H
	DD	01H
	DD	FLAT:$T229109
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsocke.cpp
xdata$x	ENDS
;	COMDAT ?Send@CClientSockE@@UAEXPADKK@Z
_TEXT	SEGMENT
_dwBufferCount$ = -28					; size = 4
tv161 = -24						; size = 4
_Lock$ = -20						; size = 4
_dwBytes$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_lpData$ = 8						; size = 4
_dwDataSize$ = 12					; size = 4
_dpidTo$ = 16						; size = 4
?Send@CClientSockE@@UAEXPADKK@Z PROC NEAR		; CClientSockE::Send, COMDAT
; _this$ = ecx

; 165  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?Send@CClientSockE@@UAEXPADKK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 10	 sub	 esp, 16			; 00000010H
  00018	55		 push	 ebp
  00019	56		 push	 esi
  0001a	8b f1		 mov	 esi, ecx

; 166  : 	ASSERT( m_hSocket != INVALID_SOCKET );
; 167  : 	DWORD dwBufferCount, dwBytes;
; 168  : 
; 169  : 	CMclAutoLock	Lock( m_lspSendBuffer.m_cs );

  0001c	8d 46 5c	 lea	 eax, DWORD PTR [esi+92]
  0001f	89 44 24 10	 mov	 DWORD PTR _Lock$[esp+36], eax
  00023	83 c0 04	 add	 eax, 4
  00026	50		 push	 eax
  00027	89 44 24 10	 mov	 DWORD PTR tv161[esp+40], eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 170  : 
; 171  : 	if( m_lspSendBuffer.IsEmpty() )

  00031	8b 46 58	 mov	 eax, DWORD PTR [esi+88]

; 172  : 	{
; 173  : 		m_lspSendBuffer.AddData( (LPBYTE)lpData, dwDataSize, m_nBufferType );

  00034	8b 54 24 28	 mov	 edx, DWORD PTR _lpData$[esp+32]
  00038	8b 4c 24 2c	 mov	 ecx, DWORD PTR _dwDataSize$[esp+32]
  0003c	85 c0		 test	 eax, eax
  0003e	8b 86 78 04 00
	00		 mov	 eax, DWORD PTR [esi+1144]
  00044	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 0
  0004c	75 7a		 jne	 SHORT $L227623
  0004e	53		 push	 ebx
  0004f	57		 push	 edi
  00050	50		 push	 eax
  00051	51		 push	 ecx
  00052	8d 7e 4c	 lea	 edi, DWORD PTR [esi+76]
  00055	52		 push	 edx
  00056	8b cf		 mov	 ecx, edi
  00058	e8 00 00 00 00	 call	 ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ; CBufferQueue::AddData

; 174  : 		m_lspSendBuffer.GetData( m_lpBuffers, &dwBufferCount );

  0005d	8d 44 24 10	 lea	 eax, DWORD PTR _dwBufferCount$[esp+44]
  00061	50		 push	 eax
  00062	8d 5e 78	 lea	 ebx, DWORD PTR [esi+120]
  00065	53		 push	 ebx
  00066	8b cf		 mov	 ecx, edi
  00068	e8 00 00 00 00	 call	 ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z ; CBufferQueue::GetData

; 175  : 
; 176  : 		int err;
; 177  : 		memset( (void*)&m_ovSend, 0, sizeof(WSAOVERLAPPED) );

  0006d	33 c9		 xor	 ecx, ecx
  0006f	8d 7e 28	 lea	 edi, DWORD PTR [esi+40]
  00072	8b d7		 mov	 edx, edi
  00074	89 0a		 mov	 DWORD PTR [edx], ecx
  00076	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00079	89 4a 08	 mov	 DWORD PTR [edx+8], ecx
  0007c	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  0007f	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 178  : 		m_ovSend.hEvent		= m_hSend;

  00082	8b 46 40	 mov	 eax, DWORD PTR [esi+64]

; 179  : 		InterlockedIncrement( &m_l );

  00085	8d 6e 48	 lea	 ebp, DWORD PTR [esi+72]
  00088	55		 push	 ebp
  00089	89 46 38	 mov	 DWORD PTR [esi+56], eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedIncrement@4

; 180  : 		if( WSASend( GetHandle(), m_lpBuffers, dwBufferCount, &dwBytes, 0, &m_ovSend, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  00092	8b 54 24 10	 mov	 edx, DWORD PTR _dwBufferCount$[esp+44]
  00096	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  00099	6a 00		 push	 0
  0009b	57		 push	 edi
  0009c	6a 00		 push	 0
  0009e	8d 4c 24 28	 lea	 ecx, DWORD PTR _dwBytes$[esp+56]
  000a2	51		 push	 ecx
  000a3	52		 push	 edx
  000a4	53		 push	 ebx
  000a5	56		 push	 esi
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000ac	85 c0		 test	 eax, eax
  000ae	5f		 pop	 edi
  000af	5b		 pop	 ebx
  000b0	74 21		 je	 SHORT $L229107
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000b8	3d e5 03 00 00	 cmp	 eax, 997		; 000003e5H
  000bd	74 14		 je	 SHORT $L229107

; 181  : 		{
; 182  : 			InterlockedDecrement( &m_l );

  000bf	55		 push	 ebp
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 183  : //			ASSERT( 0 );
; 184  : 		}
; 185  : 	}
; 186  : 	else

  000c6	eb 0b		 jmp	 SHORT $L229107
$L227623:

; 187  : 	{
; 188  : 		m_lspSendBuffer.AddData( (LPBYTE)lpData, dwDataSize, m_nBufferType );

  000c8	50		 push	 eax
  000c9	51		 push	 ecx
  000ca	52		 push	 edx
  000cb	8d 4e 4c	 lea	 ecx, DWORD PTR [esi+76]
  000ce	e8 00 00 00 00	 call	 ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ; CBufferQueue::AddData
$L229107:

; 189  : 	}
; 190  : }

  000d3	8b 44 24 0c	 mov	 eax, DWORD PTR tv161[esp+36]
  000d7	50		 push	 eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000de	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  000e2	5e		 pop	 esi
  000e3	5d		 pop	 ebp
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000eb	83 c4 1c	 add	 esp, 28			; 0000001cH
  000ee	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229079:
  00000	8d 4d ec	 lea	 ecx, DWORD PTR _Lock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
__ehhandler$?Send@CClientSockE@@UAEXPADKK@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229106
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Send@CClientSockE@@UAEXPADKK@Z ENDP			; CClientSockE::Send
PUBLIC	?SendRemnant@CClientSockE@@QAEHK@Z		; CClientSockE::SendRemnant
EXTRN	?RemoveData@CBufferQueue@@QAEXK@Z:NEAR		; CBufferQueue::RemoveData
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229166 DD	0ffffffffH
	DD	FLAT:$L229118
$T229163 DD	019930520H
	DD	01H
	DD	FLAT:$T229166
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\clientsocke.cpp
xdata$x	ENDS
;	COMDAT ?SendRemnant@CClientSockE@@QAEHK@Z
_TEXT	SEGMENT
_dwBufferCount$ = -20					; size = 4
_Lock$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_dwBytes$ = 8						; size = 4
?SendRemnant@CClientSockE@@QAEHK@Z PROC NEAR		; CClientSockE::SendRemnant, COMDAT
; _this$ = ecx

; 214  : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?SendRemnant@CClientSockE@@QAEHK@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	56		 push	 esi
  0001b	8b f1		 mov	 esi, ecx

; 215  : 	ASSERT( m_hSocket != INVALID_SOCKET );
; 216  : 	DWORD dwBufferCount;
; 217  : 	
; 218  : 	CMclAutoLock	Lock( m_lspSendBuffer.m_cs );

  0001d	8d 6e 5c	 lea	 ebp, DWORD PTR [esi+92]
  00020	89 6c 24 10	 mov	 DWORD PTR _Lock$[esp+32], ebp
  00024	83 c5 04	 add	 ebp, 4
  00027	55		 push	 ebp
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 219  : 
; 220  : 	m_lspSendBuffer.RemoveData( dwBytes );

  0002e	8b 44 24 24	 mov	 eax, DWORD PTR _dwBytes$[esp+28]
  00032	8d 5e 4c	 lea	 ebx, DWORD PTR [esi+76]
  00035	50		 push	 eax
  00036	8b cb		 mov	 ecx, ebx
  00038	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+44], 0
  00040	e8 00 00 00 00	 call	 ?RemoveData@CBufferQueue@@QAEXK@Z ; CBufferQueue::RemoveData

; 221  : 	if( m_lspSendBuffer.IsEmpty() )

  00045	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00048	85 c0		 test	 eax, eax
  0004a	75 27		 jne	 SHORT $L227653

; 222  : 	{
; 223  : 		InterlockedDecrement( &m_l );

  0004c	83 c6 48	 add	 esi, 72			; 00000048H
  0004f	56		 push	 esi
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 224  : 		return 0;

  00056	55		 push	 ebp
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	33 c0		 xor	 eax, eax
  00061	5b		 pop	 ebx

; 238  : }

  00062	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00066	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006d	83 c4 14	 add	 esp, 20			; 00000014H
  00070	c2 04 00	 ret	 4
$L227653:
  00073	57		 push	 edi

; 225  : 	}
; 226  : 	m_lspSendBuffer.GetData( m_lpBuffers, &dwBufferCount );

  00074	8d 4c 24 10	 lea	 ecx, DWORD PTR _dwBufferCount$[esp+36]
  00078	51		 push	 ecx
  00079	8d 7e 78	 lea	 edi, DWORD PTR [esi+120]
  0007c	57		 push	 edi
  0007d	8b cb		 mov	 ecx, ebx
  0007f	e8 00 00 00 00	 call	 ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z ; CBufferQueue::GetData

; 227  : 
; 228  : 	int err;
; 229  : 	memset( (void*)&m_ovSend, 0, sizeof(WSAOVERLAPPED) );

  00084	33 d2		 xor	 edx, edx
  00086	8d 46 28	 lea	 eax, DWORD PTR [esi+40]
  00089	8b c8		 mov	 ecx, eax
  0008b	89 11		 mov	 DWORD PTR [ecx], edx
  0008d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00090	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 230  : 	m_ovSend.hEvent		= m_hSend;
; 231  : 	if( WSASend( GetHandle(), m_lpBuffers, dwBufferCount, &dwBytes, 0, &m_ovSend, NULL ) != 0 && ( err = WSAGetLastError() ) != WSA_IO_PENDING )

  00093	6a 00		 push	 0
  00095	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00098	50		 push	 eax
  00099	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  0009c	8b 56 40	 mov	 edx, DWORD PTR [esi+64]
  0009f	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000a2	6a 00		 push	 0
  000a4	8d 44 24 34	 lea	 eax, DWORD PTR _dwBytes$[esp+44]
  000a8	50		 push	 eax
  000a9	89 56 38	 mov	 DWORD PTR [esi+56], edx
  000ac	8b 54 24 20	 mov	 edx, DWORD PTR _dwBufferCount$[esp+52]
  000b0	52		 push	 edx
  000b1	57		 push	 edi
  000b2	51		 push	 ecx
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSASend@28
  000b9	85 c0		 test	 eax, eax
  000bb	74 38		 je	 SHORT $L227658
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000c3	8b f8		 mov	 edi, eax
  000c5	81 ff e5 03 00
	00		 cmp	 edi, 997		; 000003e5H
  000cb	74 28		 je	 SHORT $L227658

; 232  : 	{
; 233  : 		TRACE( "i/O error, close socket %d, %x //REF:%d\n", GetHandle(), this, m_l-1 );
; 234  : 		InterlockedDecrement( &m_l );

  000cd	83 c6 48	 add	 esi, 72			; 00000048H
  000d0	56		 push	 esi
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InterlockedDecrement@4

; 235  : 		return err;

  000d7	55		 push	 ebp
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  000de	8b c7		 mov	 eax, edi
  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5d		 pop	 ebp
  000e3	5b		 pop	 ebx

; 238  : }

  000e4	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  000e8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000ef	83 c4 14	 add	 esp, 20			; 00000014H
  000f2	c2 04 00	 ret	 4
$L227658:

; 236  : 	}
; 237  : 	return 0;

  000f5	55		 push	 ebp
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 238  : }

  000fc	8b 4c 24 18	 mov	 ecx, DWORD PTR __$EHRec$[esp+36]
  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5d		 pop	 ebp
  00103	33 c0		 xor	 eax, eax
  00105	5b		 pop	 ebx
  00106	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0010d	83 c4 14	 add	 esp, 20			; 00000014H
  00110	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229118:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _Lock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
__ehhandler$?SendRemnant@CClientSockE@@QAEHK@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229163
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?SendRemnant@CClientSockE@@QAEHK@Z ENDP			; CClientSockE::SendRemnant
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCClientSockE@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCClientSockE@@UAEPAXI@Z PROC NEAR			; CClientSockE::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CClientSockE@@UAE@XZ	; CClientSockE::~CClientSockE
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L229172
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L229172:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCClientSockE@@UAEPAXI@Z ENDP			; CClientSockE::`scalar deleting destructor'
_TEXT	ENDS
END
