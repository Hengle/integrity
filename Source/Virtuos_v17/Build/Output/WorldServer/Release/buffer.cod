; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.6030 

	TITLE	\Documents and Settings\test\Mes documents\Source\Virtuos_v17\Build\Program\_Network\Net\Src\buffer.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
text$AFX_COL1	SEGMENT PARA USE32 PUBLIC ''
text$AFX_COL1	ENDS
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetWritableBufferSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetReadableBufferSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBuffer2@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@CBufferQueue@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetTail@CBufferQueue@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveHead@CBufferQueue@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0CBuffer@@QAE@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBuffer@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBuffer@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferQueue@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCBufferQueue@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CBufferQueue@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Clear@CBufferQueue@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?RemoveData@CBufferQueue@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CBufferFactory@@AAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInstance@CBufferFactory@@SAAAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsFull@?$CStack@K@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@KPAVCCtrl@@@std@@QAE@ABKABQAVCCtrl@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMax@?$CItemContainer@VCItemElem@@@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEAAPAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEAAPAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHIIPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBEABQAUtagACTMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBEABQAUtagMAGICATKMSG@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@IAE@V?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagACTMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagACTMSG@@@std@@QAEXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@IAE@V?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAUtagMAGICATKMSG@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAEXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagACTMSG@@V?$allocator@PAUtagACTMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAUtagMAGICATKMSG@@V?$allocator@PAUtagMAGICATKMSG@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagACTMSG@@@std@@QAEXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAUtagMAGICATKMSG@@@std@@QAEXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABVconst_iterator@?$vector@EV?$allocator@E@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Assign@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXVconst_iterator@01@0Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__SPAWNREGION@CEventLua@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAU__SPAWNREGION@CEventLua@@IU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@IABU12@AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAJPAJV?$allocator@J@std@@@std@@YAPAJPAJ00AAV?$allocator@J@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAJPAJ@std@@YAPAJPAJ00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUtagDROPITEM@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUtagDROPITEM@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UtagDROPITEM@@V?$allocator@UtagDROPITEM@@@std@@@std@@YAXPAUtagDROPITEM@@0AAV?$allocator@UtagDROPITEM@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUWORMON@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUWORMON@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UWORMON@@V?$allocator@UWORMON@@@std@@@std@@YAXPAUWORMON@@0AAV?$allocator@UWORMON@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEMGAME@CMiniGame@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEMGAME@CMiniGame@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEMGAME@CMiniGame@@V?$allocator@U__ITEMGAME@CMiniGame@@@std@@@std@@YAXPAU__ITEMGAME@CMiniGame@@0AAV?$allocator@U__ITEMGAME@CMiniGame@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@KV?$allocator@K@std@@@std@@YAXPAK0AAV?$allocator@K@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@HV?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__ITEM@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__ITEM@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__ITEM@CExchange@@V?$allocator@U__ITEM@CExchange@@@std@@@std@@YAXPAU__ITEM@CExchange@@0AAV?$allocator@U__ITEM@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU__POINT@CExchange@@PAU12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU__POINT@CExchange@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__POINT@CExchange@@V?$allocator@U__POINT@CExchange@@@std@@@std@@YAXPAU__POINT@CExchange@@0AAV?$allocator@U__POINT@CExchange@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAU__SPAWNREGION@CEventLua@@PAU12@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAUD3DXVECTOR3@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAUD3DXVECTOR3@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@UD3DXVECTOR3@@V?$allocator@UD3DXVECTOR3@@@std@@@std@@YAXPAUD3DXVECTOR3@@0AAV?$allocator@UD3DXVECTOR3@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAU_GIFTBOX@@PAU1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAU_GIFTBOX@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U_GIFTBOX@@V?$allocator@U_GIFTBOX@@@std@@@std@@YAXPAU_GIFTBOX@@0AAV?$allocator@U_GIFTBOX@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@JV?$allocator@J@std@@@std@@YAXPAJ0AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@JIJ@std@@YAXPAJIABJAAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@U__SPAWNREGION@CEventLua@@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAXPAU__SPAWNREGION@CEventLua@@0AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagACTMSG@@@?$allocator@PAPAUtagACTMSG@@@std@@QAE@ABV?$allocator@PAUtagACTMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagACTMSG@@@std@@YAXPAPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAUtagMAGICATKMSG@@@?$allocator@PAPAUtagMAGICATKMSG@@@std@@QAE@ABV?$allocator@PAUtagMAGICATKMSG@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAUtagMAGICATKMSG@@@std@@YAXPAPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagACTMSG@@@std@@YAXPAPAUtagACTMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAUtagMAGICATKMSG@@@std@@YAXPAPAUtagMAGICATKMSG@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UtagDROPITEM@@@std@@QAEXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UWORMON@@@std@@QAEXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEMGAME@CMiniGame@@@std@@QAEXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__ITEM@CExchange@@@std@@QAEXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__POINT@CExchange@@@std@@QAEXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@EV?$allocator@E@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@ABU34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U__SPAWNREGION@CEventLua@@@std@@QAEXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@UD3DXVECTOR3@@@std@@QAEXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_GIFTBOX@@@std@@QAEXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@EV?$allocator@E@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@AAPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAEV?$allocator@E@3@@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEAAV?$allocator@E@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@JJ@std@@YAPAJPAJ00AAV?$allocator@J@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAU__SPAWNREGION@CEventLua@@PAU12@V?$allocator@U__SPAWNREGION@CEventLua@@@std@@@std@@YAPAU__SPAWNREGION@CEventLua@@PAU12@00AAV?$allocator@U__SPAWNREGION@CEventLua@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAJIJ@std@@YAXPAJIABJ@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UtagDROPITEM@@@std@@YAXPAUtagDROPITEM@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UWORMON@@@std@@YAXPAUWORMON@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEMGAME@CMiniGame@@@std@@YAXPAU__ITEMGAME@CMiniGame@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__ITEM@CExchange@@@std@@YAXPAU__ITEM@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__POINT@CExchange@@@std@@YAXPAU__POINT@CExchange@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@U__SPAWNREGION@CEventLua@@U12@@std@@YAXPAU__SPAWNREGION@CEventLua@@ABU12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U__SPAWNREGION@CEventLua@@@std@@YAXPAU__SPAWNREGION@CEventLua@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@UD3DXVECTOR3@@@std@@YAXPAUD3DXVECTOR3@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_GIFTBOX@@@std@@YAXPAU_GIFTBOX@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@E@std@@QAEXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@E@std@@QAEXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEABEXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Insert@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXViterator@01@Vconst_iterator@01@1Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@EE@std@@YAXPAEABE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@E@std@@YAXPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAEPAE@std@@YAPAEPAE00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@I@std@@YAXVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0AAIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAEPAEV?$allocator@E@std@@@std@@YAPAEPAE00AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Advance@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@H@std@@YAXAAVconst_iterator@?$vector@EV?$allocator@E@std@@@0@HUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@PAE@std@@YAPAEVconst_iterator@?$vector@EV?$allocator@E@std@@@0@0PAEU_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yconst_iterator@?$vector@EV?$allocator@E@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@EE@std@@YAPAEPAE00AAV?$allocator@E@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@EV?$allocator@E@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEVconst_iterator@01@0PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@E@std@@QAEPAEI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@E@std@@YAPAEIPAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@E@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@EV?$allocator@E@std@@@std@@QAE@PAE@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@EV?$allocator@E@std@@@std@@YAXPAE0AAV?$allocator@E@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ptr_cat@std@@YA?AU_Scalar_ptr_iterator_tag@1@PAJ0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KEU?$less@K@std@@V?$allocator@U?$pair@$$CBKE@std@@@2@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCCtrl@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCCtrl@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@KPAVCUser@@U?$less@K@std@@V?$allocator@U?$pair@$$CBKPAVCUser@@@std@@@3@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@G@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_factory@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4V2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ?$S3@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4IA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CMclCritSec@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBufferQueue@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CBuffer@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CBuffer2@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?GetHeaderLength@CBuffer@@QAEKXZ		; CBuffer::GetHeaderLength
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
;	COMDAT ?GetHeaderLength@CBuffer@@QAEKXZ
_TEXT	SEGMENT
?GetHeaderLength@CBuffer@@QAEKXZ PROC NEAR		; CBuffer::GetHeaderLength, COMDAT
; _this$ = ecx

; 66   : 		return m_dwHeaderSize;

  00000	8b 81 24 20 00
	00		 mov	 eax, DWORD PTR [ecx+8228]

; 67   : 	}

  00006	c3		 ret	 0
?GetHeaderLength@CBuffer@@QAEKXZ ENDP			; CBuffer::GetHeaderLength
_TEXT	ENDS
PUBLIC	?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetWritableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetWritableBuffer, COMDAT
; _this$ = ecx

; 104  : 	*pnBufSize	= (int)( m_lpBufMax - m_pTail );	

  00000	8b 91 18 20 00
	00		 mov	 edx, DWORD PTR [ecx+8216]
  00006	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 105  : 	return m_pTail;	

  00014	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]

; 106  : }

  0001a	c2 04 00	 ret	 4
?GetWritableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetWritableBuffer
_TEXT	ENDS
PUBLIC	?GetWritableBufferSize@CBuffer@@QAEHXZ		; CBuffer::GetWritableBufferSize
; Function compile flags: /Ogty
;	COMDAT ?GetWritableBufferSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT
?GetWritableBufferSize@CBuffer@@QAEHXZ PROC NEAR	; CBuffer::GetWritableBufferSize, COMDAT
; _this$ = ecx

; 110  : 	return (int)( m_lpBufMax - m_pTail );	

  00000	8b 81 10 20 00
	00		 mov	 eax, DWORD PTR [ecx+8208]
  00006	2b 81 18 20 00
	00		 sub	 eax, DWORD PTR [ecx+8216]

; 111  : }

  0000c	c3		 ret	 0
?GetWritableBufferSize@CBuffer@@QAEHXZ ENDP		; CBuffer::GetWritableBufferSize
_TEXT	ENDS
PUBLIC	?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z		; CBuffer::GetReadableBuffer
; Function compile flags: /Ogty
;	COMDAT ?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z
_TEXT	SEGMENT
_pnBufSize$ = 8						; size = 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z PROC NEAR	; CBuffer::GetReadableBuffer, COMDAT
; _this$ = ecx

; 115  : 	*pnBufSize	= (int)( m_pTail - m_pHead );	

  00000	8b 91 14 20 00
	00		 mov	 edx, DWORD PTR [ecx+8212]
  00006	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]
  0000c	2b c2		 sub	 eax, edx
  0000e	8b 54 24 04	 mov	 edx, DWORD PTR _pnBufSize$[esp-4]
  00012	89 02		 mov	 DWORD PTR [edx], eax

; 116  : 	return m_pHead;	

  00014	8b 81 14 20 00
	00		 mov	 eax, DWORD PTR [ecx+8212]

; 117  : }

  0001a	c2 04 00	 ret	 4
?GetReadableBuffer@CBuffer@@QAEPAEPAH@Z ENDP		; CBuffer::GetReadableBuffer
_TEXT	ENDS
PUBLIC	?GetReadableBufferSize@CBuffer@@QAEHXZ		; CBuffer::GetReadableBufferSize
; Function compile flags: /Ogty
;	COMDAT ?GetReadableBufferSize@CBuffer@@QAEHXZ
_TEXT	SEGMENT
?GetReadableBufferSize@CBuffer@@QAEHXZ PROC NEAR	; CBuffer::GetReadableBufferSize, COMDAT
; _this$ = ecx

; 121  : 	return (int)( m_pTail - m_pHead );	

  00000	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]
  00006	2b 81 14 20 00
	00		 sub	 eax, DWORD PTR [ecx+8212]

; 122  : }

  0000c	c3		 ret	 0
?GetReadableBufferSize@CBuffer@@QAEHXZ ENDP		; CBuffer::GetReadableBufferSize
_TEXT	ENDS
PUBLIC	?GetHead@CBufferQueue@@QAEPAVCBuffer@@XZ	; CBufferQueue::GetHead
; Function compile flags: /Ogty
;	COMDAT ?GetHead@CBufferQueue@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT
?GetHead@CBufferQueue@@QAEPAVCBuffer@@XZ PROC NEAR	; CBufferQueue::GetHead, COMDAT
; _this$ = ecx

; 216  : 	{	return m_pHead;	}

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetHead@CBufferQueue@@QAEPAVCBuffer@@XZ ENDP		; CBufferQueue::GetHead
_TEXT	ENDS
PUBLIC	?GetTail@CBufferQueue@@QAEPAVCBuffer@@XZ	; CBufferQueue::GetTail
; Function compile flags: /Ogty
;	COMDAT ?GetTail@CBufferQueue@@QAEPAVCBuffer@@XZ
_TEXT	SEGMENT
?GetTail@CBufferQueue@@QAEPAVCBuffer@@XZ PROC NEAR	; CBufferQueue::GetTail, COMDAT
; _this$ = ecx

; 218  : 	{	return m_pTail;	}

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetTail@CBufferQueue@@QAEPAVCBuffer@@XZ ENDP		; CBufferQueue::GetTail
_TEXT	ENDS
PUBLIC	?IsEmpty@CBufferQueue@@QAEHXZ			; CBufferQueue::IsEmpty
; Function compile flags: /Ogty
;	COMDAT ?IsEmpty@CBufferQueue@@QAEHXZ
_TEXT	SEGMENT
?IsEmpty@CBufferQueue@@QAEHXZ PROC NEAR			; CBufferQueue::IsEmpty, COMDAT
; _this$ = ecx

; 222  : 	{	return( m_uCount == 0 );	}

  00000	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00003	33 c0		 xor	 eax, eax
  00005	85 d2		 test	 edx, edx
  00007	0f 94 c0	 sete	 al
  0000a	c3		 ret	 0
?IsEmpty@CBufferQueue@@QAEHXZ ENDP			; CBufferQueue::IsEmpty
_TEXT	ENDS
PUBLIC	?RemoveHead@CBufferQueue@@QAEXXZ		; CBufferQueue::RemoveHead
; Function compile flags: /Ogty
;	COMDAT ?RemoveHead@CBufferQueue@@QAEXXZ
_TEXT	SEGMENT
?RemoveHead@CBufferQueue@@QAEXXZ PROC NEAR		; CBufferQueue::RemoveHead, COMDAT
; _this$ = ecx

; 238  : //	CMclAutoLock	Lock( m_cs );
; 239  : //	Remove it from active list
; 240  : 	if( !IsEmpty() )

  00000	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  00003	33 d2		 xor	 edx, edx
  00005	3b c2		 cmp	 eax, edx
  00007	74 27		 je	 SHORT $L228789

; 241  : 	{
; 242  : 		if( m_pTail == m_pHead )

  00009	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0000c	39 41 08	 cmp	 DWORD PTR [ecx+8], eax
  0000f	75 03		 jne	 SHORT $L227375

; 243  : 			m_pTail	= NULL;

  00011	89 51 08	 mov	 DWORD PTR [ecx+8], edx
$L227375:

; 244  : 		if( m_pHead->pNext )

  00014	8b 80 1c 20 00
	00		 mov	 eax, DWORD PTR [eax+8220]
  0001a	3b c2		 cmp	 eax, edx
  0001c	74 06		 je	 SHORT $L227376

; 245  : 			m_pHead->pNext->pPrevious	= NULL;

  0001e	89 90 20 20 00
	00		 mov	 DWORD PTR [eax+8224], edx
$L227376:

; 246  : 		m_pHead		= m_pHead->pNext;

  00024	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00027	8b 90 1c 20 00
	00		 mov	 edx, DWORD PTR [eax+8220]
  0002d	89 51 04	 mov	 DWORD PTR [ecx+4], edx
$L228789:

; 247  : 	}
; 248  : 	m_uCount--;

  00030	ff 49 0c	 dec	 DWORD PTR [ecx+12]

; 249  : }

  00033	c3		 ret	 0
?RemoveHead@CBufferQueue@@QAEXXZ ENDP			; CBufferQueue::RemoveHead
_TEXT	ENDS
PUBLIC	??0CBuffer@@QAE@K@Z				; CBuffer::CBuffer
PUBLIC	?GetPacketSize@CBuffer@@UAEKPAE@Z		; CBuffer::GetPacketSize
PUBLIC	?SetHeader@CBuffer@@UAEXK@Z			; CBuffer::SetHeader
PUBLIC	??_7CBuffer@@6B@				; CBuffer::`vftable'
PUBLIC	??_GCBuffer@@UAEPAXI@Z				; CBuffer::`scalar deleting destructor'
EXTRN	?Malloc@CHeapMng@@QAEPAXI@Z:NEAR		; CHeapMng::Malloc
EXTRN	??_ECBuffer@@UAEPAXI@Z:NEAR			; CBuffer::`vector deleting destructor'
;	COMDAT ??_7CBuffer@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
CONST	SEGMENT
??_7CBuffer@@6B@ DD FLAT:??_ECBuffer@@UAEPAXI@Z		; CBuffer::`vftable'
	DD	FLAT:?GetPacketSize@CBuffer@@UAEKPAE@Z
	DD	FLAT:?SetHeader@CBuffer@@UAEXK@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CBuffer@@QAE@K@Z
_TEXT	SEGMENT
_uBufSize$ = 8						; size = 4
??0CBuffer@@QAE@K@Z PROC NEAR				; CBuffer::CBuffer, COMDAT
; _this$ = ecx

; 38   : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 39   : 	if( uBufSize > MAX_BUFFER ) {

  00002	8b 7c 24 0c	 mov	 edi, DWORD PTR _uBufSize$[esp+4]
  00006	81 ff 00 20 00
	00		 cmp	 edi, 8192		; 00002000H
  0000c	8b f1		 mov	 esi, ecx
  0000e	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBuffer@@6B@
  00014	76 0e		 jbe	 SHORT $L227407

; 40   : 		m_lpBufStart	= (LPBYTE)CBuffer::m_pHeapMng->Malloc( uBufSize );

  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A ; CBuffer::m_pHeapMng
  0001c	57		 push	 edi
  0001d	e8 00 00 00 00	 call	 ?Malloc@CHeapMng@@QAEPAXI@Z ; CHeapMng::Malloc

; 41   : //		ASSERT( m_lpBufStart );
; 42   : 	}
; 43   : 	else {

  00022	eb 08		 jmp	 SHORT $L228793
$L227407:

; 44   : 		m_lpBufStart	= m_lpBuf;

  00024	8d 46 0c	 lea	 eax, DWORD PTR [esi+12]

; 45   : 		uBufSize	= MAX_BUFFER;

  00027	bf 00 20 00 00	 mov	 edi, 8192		; 00002000H
$L228793:
  0002c	89 86 0c 20 00
	00		 mov	 DWORD PTR [esi+8204], eax

; 46   : 	}
; 47   : 	m_pHead		= m_pTail	= m_lpBufStart;

  00032	89 86 18 20 00
	00		 mov	 DWORD PTR [esi+8216], eax
  00038	89 86 14 20 00
	00		 mov	 DWORD PTR [esi+8212], eax

; 48   : 	m_lpBufMax	= m_lpBufStart + uBufSize;

  0003e	03 c7		 add	 eax, edi
  00040	89 86 10 20 00
	00		 mov	 DWORD PTR [esi+8208], eax

; 49   : 	cb	= 0;

  00046	33 c0		 xor	 eax, eax
  00048	89 46 08	 mov	 DWORD PTR [esi+8], eax

; 50   : 	dpid	= DPID_UNKNOWN;
; 51   : 	pPrevious	= pNext		= NULL;

  0004b	89 86 1c 20 00
	00		 mov	 DWORD PTR [esi+8220], eax
  00051	89 86 20 20 00
	00		 mov	 DWORD PTR [esi+8224], eax
  00057	5f		 pop	 edi
  00058	c7 46 04 ff ff
	ff ff		 mov	 DWORD PTR [esi+4], -1

; 52   : 	m_dwHeaderSize = sizeof(DWORD) + 1;

  0005f	c7 86 24 20 00
	00 05 00 00 00	 mov	 DWORD PTR [esi+8228], 5

; 53   : }

  00069	8b c6		 mov	 eax, esi
  0006b	5e		 pop	 esi
  0006c	c2 04 00	 ret	 4
??0CBuffer@@QAE@K@Z ENDP				; CBuffer::CBuffer
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
_TEXT	ENDS
;	COMDAT ?GetPacketSize@CBuffer@@UAEKPAE@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?GetPacketSize@CBuffer@@UAEKPAE@Z PROC NEAR		; CBuffer::GetPacketSize, COMDAT
; _this$ = ecx

; 71   : 		return *(UNALIGNED LPDWORD)(ptr + 1);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00004	8b 40 01	 mov	 eax, DWORD PTR [eax+1]

; 72   : 	}

  00007	c2 04 00	 ret	 4
?GetPacketSize@CBuffer@@UAEKPAE@Z ENDP			; CBuffer::GetPacketSize
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ?SetHeader@CBuffer@@UAEXK@Z
_TEXT	SEGMENT
_uDataSize$ = 8						; size = 4
?SetHeader@CBuffer@@UAEXK@Z PROC NEAR			; CBuffer::SetHeader, COMDAT
; _this$ = ecx

; 76   : 		*m_pTail					= HEADERMARK;

  00000	8b 81 18 20 00
	00		 mov	 eax, DWORD PTR [ecx+8216]
  00006	c6 00 31	 mov	 BYTE PTR [eax], 49	; 00000031H

; 77   : 		m_pTail++;

  00009	8b 91 18 20 00
	00		 mov	 edx, DWORD PTR [ecx+8216]
  0000f	42		 inc	 edx
  00010	89 91 18 20 00
	00		 mov	 DWORD PTR [ecx+8216], edx
  00016	8b c2		 mov	 eax, edx

; 78   : 
; 79   : 		*(UNALIGNED DWORD*)m_pTail	= (DWORD)uDataSize;

  00018	8b 54 24 04	 mov	 edx, DWORD PTR _uDataSize$[esp-4]
  0001c	89 10		 mov	 DWORD PTR [eax], edx

; 80   : 		m_pTail += sizeof(DWORD);

  0001e	83 81 18 20 00
	00 04		 add	 DWORD PTR [ecx+8216], 4

; 81   : 	}

  00025	c2 04 00	 ret	 4
?SetHeader@CBuffer@@UAEXK@Z ENDP			; CBuffer::SetHeader
_TEXT	ENDS
PUBLIC	??1CBuffer@@UAE@XZ				; CBuffer::~CBuffer
EXTRN	?Free@CHeapMng@@QAEXPAX@Z:NEAR			; CHeapMng::Free
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
;	COMDAT ??1CBuffer@@UAE@XZ
_TEXT	SEGMENT
??1CBuffer@@UAE@XZ PROC NEAR				; CBuffer::~CBuffer, COMDAT
; _this$ = ecx

; 57   : 	if( m_lpBufMax - m_lpBufStart > MAX_BUFFER )

  00000	8b 81 0c 20 00
	00		 mov	 eax, DWORD PTR [ecx+8204]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CBuffer@@6B@
  0000c	8b 89 10 20 00
	00		 mov	 ecx, DWORD PTR [ecx+8208]
  00012	2b c8		 sub	 ecx, eax
  00014	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  0001a	7e 0c		 jle	 SHORT $L227418

; 58   : 	{
; 59   : #ifdef __SO1014
; 60   : 		if( m_lpBufStart )
; 61   : #endif	// __SO1014
; 62   : #ifdef __VM_0819
; 63   : 			CBuffer::m_pHeapMng->Free( m_lpBufStart, GetSize() );
; 64   : #else	// __VM_0819
; 65   : 			CBuffer::m_pHeapMng->Free( m_lpBufStart );

  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A ; CBuffer::m_pHeapMng
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Free@CHeapMng@@QAEXPAX@Z ; CHeapMng::Free
$L227418:

; 66   : #endif	// __VM_0819
; 67   : 	}
; 68   : }

  00028	c3		 ret	 0
??1CBuffer@@UAE@XZ ENDP					; CBuffer::~CBuffer
_TEXT	ENDS
PUBLIC	?RemoveData@CBufferQueue@@QAEXK@Z		; CBufferQueue::RemoveData
PUBLIC	??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@ ; `string'
PUBLIC	??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@		; `string'
EXTRN	?Error@@YAPBDPBDZZ:NEAR				; Error
;	COMDAT ??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
CONST	SEGMENT
??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@ DB '\Documents '
	DB	'and Settings\test\Mes documents\Source\Virtuos_v17\Build\Prog'
	DB	'ram\_Network\Net\Src\buffer.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
CONST	SEGMENT
??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@ DB '%s %d', 00H	; `string'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
CONST	ENDS
;	COMDAT ?RemoveData@CBufferQueue@@QAEXK@Z
_TEXT	SEGMENT
___loop$ = 8						; size = 4
_uDataSize$ = 8						; size = 4
?RemoveData@CBufferQueue@@QAEXK@Z PROC NEAR		; CBufferQueue::RemoveData, COMDAT
; _this$ = ecx

; 219  : {

  00000	53		 push	 ebx

; 220  : 	CBuffer* pBuffer;
; 221  : 	
; 222  : //	CMclAutoLock	Lock( m_cs );
; 223  : 	u_long uRemnant;
; 224  : 
; 225  : 	INIT_LOOP;
; 226  : 	while( uDataSize > 0 )

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _uDataSize$[esp]
  00005	55		 push	 ebp
  00006	33 ed		 xor	 ebp, ebp
  00008	33 c0		 xor	 eax, eax
  0000a	3b dd		 cmp	 ebx, ebp
  0000c	56		 push	 esi
  0000d	8b f1		 mov	 esi, ecx
  0000f	76 7e		 jbe	 SHORT $L228828
  00011	57		 push	 edi
$L227479:

; 227  : 	{
; 228  : 		VERIFY_LOOP( __FILE__, __LINE__ );

  00012	40		 inc	 eax
  00013	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  00018	89 44 24 14	 mov	 DWORD PTR ___loop$[esp+12], eax
  0001c	75 17		 jne	 SHORT $L227481
  0001e	68 e4 00 00 00	 push	 228			; 000000e4H
  00023	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@
  00028	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  0002d	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
$L227481:

; 229  : 
; 230  : 		pBuffer	= GetHead();

  00035	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]

; 231  : //		ASSERT( pBuffer );
; 232  : 		if( NULL == pBuffer )

  00038	3b cd		 cmp	 ecx, ebp
  0003a	74 52		 je	 SHORT $L228830

; 233  : 			return;
; 234  : 
; 235  : 		uRemnant	= pBuffer->GetReadableBufferSize();

  0003c	8b b9 18 20 00
	00		 mov	 edi, DWORD PTR [ecx+8216]
  00042	2b b9 14 20 00
	00		 sub	 edi, DWORD PTR [ecx+8212]

; 236  : 		if( uRemnant > uDataSize )

  00048	3b fb		 cmp	 edi, ebx
  0004a	77 3c		 ja	 SHORT $L228829

; 239  : 			uDataSize	= 0;
; 240  : 		}
; 241  : 		else
; 242  : 		{
; 243  : 			RemoveHead();

  0004c	39 6e 0c	 cmp	 DWORD PTR [esi+12], ebp
  0004f	74 24		 je	 SHORT $L228821
  00051	39 4e 08	 cmp	 DWORD PTR [esi+8], ecx
  00054	75 03		 jne	 SHORT $L228822
  00056	89 6e 08	 mov	 DWORD PTR [esi+8], ebp
$L228822:
  00059	8b 81 1c 20 00
	00		 mov	 eax, DWORD PTR [ecx+8220]
  0005f	3b c5		 cmp	 eax, ebp
  00061	74 06		 je	 SHORT $L228823
  00063	89 a8 20 20 00
	00		 mov	 DWORD PTR [eax+8224], ebp
$L228823:
  00069	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  0006c	8b 90 1c 20 00
	00		 mov	 edx, DWORD PTR [eax+8220]
  00072	89 56 04	 mov	 DWORD PTR [esi+4], edx
$L228821:
  00075	ff 4e 0c	 dec	 DWORD PTR [esi+12]

; 244  : //			SAFE_DELETE( pBuffer );
; 245  : 			safe_delete( pBuffer );

  00078	8b 01		 mov	 eax, DWORD PTR [ecx]
  0007a	6a 01		 push	 1
  0007c	ff 10		 call	 DWORD PTR [eax]

; 246  : 			uDataSize	-= uRemnant;

  0007e	2b df		 sub	 ebx, edi
  00080	74 0c		 je	 SHORT $L228830

; 220  : 	CBuffer* pBuffer;
; 221  : 	
; 222  : //	CMclAutoLock	Lock( m_cs );
; 223  : 	u_long uRemnant;
; 224  : 
; 225  : 	INIT_LOOP;
; 226  : 	while( uDataSize > 0 )

  00082	8b 44 24 14	 mov	 eax, DWORD PTR ___loop$[esp+12]
  00086	eb 8a		 jmp	 SHORT $L227479
$L228829:

; 237  : 		{
; 238  : 			pBuffer->m_pHead	+= uDataSize;

  00088	01 99 14 20 00
	00		 add	 DWORD PTR [ecx+8212], ebx
$L228830:
  0008e	5f		 pop	 edi
$L228828:
  0008f	5e		 pop	 esi
  00090	5d		 pop	 ebp
  00091	5b		 pop	 ebx

; 247  : 		}
; 248  : 	}
; 249  : }

  00092	c2 04 00	 ret	 4
?RemoveData@CBufferQueue@@QAEXK@Z ENDP			; CBufferQueue::RemoveData
_TEXT	ENDS
PUBLIC	?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z	; CBufferQueue::GetData
; Function compile flags: /Ogty
;	COMDAT ?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z
_TEXT	SEGMENT
_lpBuffers$ = 8						; size = 4
_lpdwBufferCount$ = 12					; size = 4
?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z PROC NEAR	; CBufferQueue::GetData, COMDAT
; _this$ = ecx

; 253  : 	CBuffer* pBuffer;
; 254  : 	int	i	= 0;
; 255  : //	*lpdwBufferCount	= 0;
; 256  : //	CMclAutoLock	Lock( m_cs );	
; 257  : 	pBuffer	= GetHead();

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	33 d2		 xor	 edx, edx

; 258  : 
; 259  : 	while( pBuffer && i < MAX_WSABUF )

  00005	85 c0		 test	 eax, eax
  00007	74 3d		 je	 SHORT $L228843
  00009	8b 4c 24 04	 mov	 ecx, DWORD PTR _lpBuffers$[esp-4]
  0000d	56		 push	 esi
  0000e	8b ff		 npad	 2
$L227496:
  00010	81 fa 80 00 00
	00		 cmp	 edx, 128		; 00000080H
  00016	7d 24		 jge	 SHORT $L228844

; 260  : 	{
; 261  : 		lpBuffers[i].buf	= (char*)pBuffer->GetReadableBuffer( (int*)&lpBuffers[i].len );

  00018	8b b0 18 20 00
	00		 mov	 esi, DWORD PTR [eax+8216]
  0001e	2b b0 14 20 00
	00		 sub	 esi, DWORD PTR [eax+8212]
  00024	89 34 d1	 mov	 DWORD PTR [ecx+edx*8], esi
  00027	8b b0 14 20 00
	00		 mov	 esi, DWORD PTR [eax+8212]
  0002d	89 74 d1 04	 mov	 DWORD PTR [ecx+edx*8+4], esi

; 262  : 		i++;
; 263  : 		pBuffer	= pBuffer->pNext;

  00031	8b 80 1c 20 00
	00		 mov	 eax, DWORD PTR [eax+8220]
  00037	42		 inc	 edx
  00038	85 c0		 test	 eax, eax
  0003a	75 d4		 jne	 SHORT $L227496
$L228844:

; 264  : 	}
; 265  : 	*lpdwBufferCount	= i;

  0003c	8b 44 24 0c	 mov	 eax, DWORD PTR _lpdwBufferCount$[esp]
  00040	89 10		 mov	 DWORD PTR [eax], edx
  00042	5e		 pop	 esi

; 266  : }

  00043	c2 08 00	 ret	 8
$L228843:

; 264  : 	}
; 265  : 	*lpdwBufferCount	= i;

  00046	8b 4c 24 08	 mov	 ecx, DWORD PTR _lpdwBufferCount$[esp-4]
  0004a	89 11		 mov	 DWORD PTR [ecx], edx

; 266  : }

  0004c	c2 08 00	 ret	 8
?GetData@CBufferQueue@@QAEXPAU_WSABUF@@PAK@Z ENDP	; CBufferQueue::GetData
_TEXT	ENDS
PUBLIC	??0CBufferFactory@@AAE@XZ			; CBufferFactory::CBufferFactory
; Function compile flags: /Ogty
;	COMDAT ??0CBufferFactory@@AAE@XZ
_TEXT	SEGMENT
??0CBufferFactory@@AAE@XZ PROC NEAR			; CBufferFactory::CBufferFactory, COMDAT
; _this$ = ecx

; 270  : {

  00000	8b c1		 mov	 eax, ecx

; 271  : }

  00002	c3		 ret	 0
??0CBufferFactory@@AAE@XZ ENDP				; CBufferFactory::CBufferFactory
_TEXT	ENDS
PUBLIC	?GetInstance@CBufferFactory@@SAAAV1@XZ		; CBufferFactory::GetInstance
;	COMDAT ?g_factory@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4V2@A
_BSS	SEGMENT
?g_factory@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4V2@A DB 01H DUP (?) ; `CBufferFactory::GetInstance'::`2'::g_factory
_BSS	ENDS
;	COMDAT ?$S3@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4IA
_BSS	SEGMENT
?$S3@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4IA DD 01H DUP (?) ; `CBufferFactory::GetInstance'::`2'::$S3
; Function compile flags: /Ogty
_BSS	ENDS
;	COMDAT ?GetInstance@CBufferFactory@@SAAAV1@XZ
_TEXT	SEGMENT
?GetInstance@CBufferFactory@@SAAAV1@XZ PROC NEAR	; CBufferFactory::GetInstance, COMDAT

; 275  : 	static CBufferFactory g_factory;

  00000	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?$S3@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4IA
  00006	b8 01 00 00 00	 mov	 eax, 1
  0000b	84 c8		 test	 cl, al
  0000d	75 06		 jne	 SHORT $L228857
  0000f	09 05 00 00 00
	00		 or	 DWORD PTR ?$S3@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4IA, eax
$L228857:

; 276  : 	return g_factory;

  00015	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:?g_factory@?1??GetInstance@CBufferFactory@@SAAAV2@XZ@4V2@A

; 277  : }

  0001a	c3		 ret	 0
?GetInstance@CBufferFactory@@SAAAV1@XZ ENDP		; CBufferFactory::GetInstance
_TEXT	ENDS
PUBLIC	??0CMclCritSec@@QAE@XZ				; CMclCritSec::CMclCritSec
PUBLIC	??_7CMclCritSec@@6B@				; CMclCritSec::`vftable'
PUBLIC	??_GCMclCritSec@@UAEPAXI@Z			; CMclCritSec::`scalar deleting destructor'
EXTRN	??_ECMclCritSec@@UAEPAXI@Z:NEAR			; CMclCritSec::`vector deleting destructor'
EXTRN	__imp__InitializeCriticalSection@4:NEAR
;	COMDAT ??_7CMclCritSec@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
CONST	SEGMENT
??_7CMclCritSec@@6B@ DD FLAT:??_ECMclCritSec@@UAEPAXI@Z	; CMclCritSec::`vftable'
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CMclCritSec@@QAE@XZ
_TEXT	SEGMENT
??0CMclCritSec@@QAE@XZ PROC NEAR			; CMclCritSec::CMclCritSec, COMDAT
; _this$ = ecx

; 19   :     CMclCritSec(void)

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 20   :     {
; 21   : 		::InitializeCriticalSection( &m_CritSec );

  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CMclCritSec@@6B@
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 22   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c3		 ret	 0
??0CMclCritSec@@QAE@XZ ENDP				; CMclCritSec::CMclCritSec
_TEXT	ENDS
PUBLIC	??1CMclCritSec@@UAE@XZ				; CMclCritSec::~CMclCritSec
EXTRN	__imp__DeleteCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ??1CMclCritSec@@UAE@XZ
_TEXT	SEGMENT
??1CMclCritSec@@UAE@XZ PROC NEAR			; CMclCritSec::~CMclCritSec, COMDAT
; _this$ = ecx

; 26   : 	{

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CMclCritSec@@6B@

; 27   : 		::DeleteCriticalSection( &m_CritSec );

  00006	83 c1 04	 add	 ecx, 4
  00009	51		 push	 ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4

; 28   : 	}

  00010	c3		 ret	 0
??1CMclCritSec@@UAE@XZ ENDP				; CMclCritSec::~CMclCritSec
_TEXT	ENDS
PUBLIC	?Enter@CMclCritSec@@QAEXXZ			; CMclCritSec::Enter
EXTRN	__imp__EnterCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Enter@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Enter@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Enter, COMDAT
; _this$ = ecx

; 33   : 		::EnterCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 34   : 	}

  0000a	c3		 ret	 0
?Enter@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Enter
_TEXT	ENDS
PUBLIC	?Leave@CMclCritSec@@QAEXXZ			; CMclCritSec::Leave
EXTRN	__imp__LeaveCriticalSection@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?Leave@CMclCritSec@@QAEXXZ
_TEXT	SEGMENT
?Leave@CMclCritSec@@QAEXXZ PROC NEAR			; CMclCritSec::Leave, COMDAT
; _this$ = ecx

; 39   : 		::LeaveCriticalSection( &m_CritSec );

  00000	83 c1 04	 add	 ecx, 4
  00003	51		 push	 ecx
  00004	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 40   : 	}

  0000a	c3		 ret	 0
?Leave@CMclCritSec@@QAEXXZ ENDP				; CMclCritSec::Leave
_TEXT	ENDS
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
; Function compile flags: /Ogty
;	COMDAT ??_GCMclCritSec@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCMclCritSec@@UAEPAXI@Z PROC NEAR			; CMclCritSec::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00006	50		 push	 eax
  00007	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CMclCritSec@@6B@
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00013	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00018	74 09		 je	 SHORT $L228876
  0001a	56		 push	 esi
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00020	83 c4 04	 add	 esp, 4
$L228876:
  00023	8b c6		 mov	 eax, esi
  00025	5e		 pop	 esi
  00026	c2 04 00	 ret	 4
??_GCMclCritSec@@UAEPAXI@Z ENDP				; CMclCritSec::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z		; CMclAutoLock::CMclAutoLock
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclautolock.h
;	COMDAT ??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z
_TEXT	SEGMENT
_rCMclCritSec$ = 8					; size = 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z PROC NEAR	; CMclAutoLock::CMclAutoLock, COMDAT
; _this$ = ecx

; 20   : 	{
; 21   : 		m_pcCritSec = &rCMclCritSec;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _rCMclCritSec$[esp-4]
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	89 06		 mov	 DWORD PTR [esi], eax

; 22   : 		m_pcCritSec->Enter();

  00009	83 c0 04	 add	 eax, 4
  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 23   : 	}

  00013	8b c6		 mov	 eax, esi
  00015	5e		 pop	 esi
  00016	c2 04 00	 ret	 4
??0CMclAutoLock@@QAE@AAVCMclCritSec@@@Z ENDP		; CMclAutoLock::CMclAutoLock
_TEXT	ENDS
PUBLIC	??1CMclAutoLock@@QAE@XZ				; CMclAutoLock::~CMclAutoLock
; Function compile flags: /Ogty
;	COMDAT ??1CMclAutoLock@@QAE@XZ
_TEXT	SEGMENT
??1CMclAutoLock@@QAE@XZ PROC NEAR			; CMclAutoLock::~CMclAutoLock, COMDAT
; _this$ = ecx

; 28   : 		m_pcCritSec->Leave();

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]
  00002	83 c0 04	 add	 eax, 4
  00005	50		 push	 eax
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 29   : 	}

  0000c	c3		 ret	 0
??1CMclAutoLock@@QAE@XZ ENDP				; CMclAutoLock::~CMclAutoLock
_TEXT	ENDS
PUBLIC	??0CBuffer2@@QAE@K@Z				; CBuffer2::CBuffer2
PUBLIC	?GetPacketSize@CBuffer2@@UAEKPAE@Z		; CBuffer2::GetPacketSize
PUBLIC	?SetHeader@CBuffer2@@UAEXK@Z			; CBuffer2::SetHeader
PUBLIC	??_7CBuffer2@@6B@				; CBuffer2::`vftable'
PUBLIC	??_GCBuffer2@@UAEPAXI@Z				; CBuffer2::`scalar deleting destructor'
EXTRN	??_ECBuffer2@@UAEPAXI@Z:NEAR			; CBuffer2::`vector deleting destructor'
;	COMDAT ??_7CBuffer2@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
CONST	SEGMENT
??_7CBuffer2@@6B@ DD FLAT:??_ECBuffer2@@UAEPAXI@Z	; CBuffer2::`vftable'
	DD	FLAT:?GetPacketSize@CBuffer2@@UAEKPAE@Z
	DD	FLAT:?SetHeader@CBuffer2@@UAEXK@Z
; Function compile flags: /Ogty
CONST	ENDS
;	COMDAT ??0CBuffer2@@QAE@K@Z
_TEXT	SEGMENT
_uBufSize$ = 8						; size = 4
??0CBuffer2@@QAE@K@Z PROC NEAR				; CBuffer2::CBuffer2, COMDAT
; _this$ = ecx

; 132  : 	{

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uBufSize$[esp-4]
  00004	56		 push	 esi
  00005	50		 push	 eax
  00006	8b f1		 mov	 esi, ecx
  00008	e8 00 00 00 00	 call	 ??0CBuffer@@QAE@K@Z	; CBuffer::CBuffer
  0000d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBuffer2@@6B@

; 133  : 		m_dwHeaderSize = 2;

  00013	c7 86 24 20 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+8228], 2

; 134  : 	}

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi
  00020	c2 04 00	 ret	 4
??0CBuffer2@@QAE@K@Z ENDP				; CBuffer2::CBuffer2
_TEXT	ENDS
EXTRN	__imp__ntohs@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?GetPacketSize@CBuffer2@@UAEKPAE@Z
_TEXT	SEGMENT
_ptr$ = 8						; size = 4
?GetPacketSize@CBuffer2@@UAEKPAE@Z PROC NEAR		; CBuffer2::GetPacketSize, COMDAT
; _this$ = ecx

; 138  : //		DWORD dwSize = *(WORD *)ptr;
; 139  : //		dwSize -= 2;
; 140  : //		return dwSize;
; 141  : 		DWORD dwSize = ntohs( *(WORD *)ptr );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ptr$[esp-4]
  00004	33 c9		 xor	 ecx, ecx
  00006	66 8b 08	 mov	 cx, WORD PTR [eax]
  00009	51		 push	 ecx
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ntohs@4

; 142  : 		dwSize -= 2;
; 143  : 		return dwSize;

  00010	0f b7 c0	 movzx	 eax, ax
  00013	83 e8 02	 sub	 eax, 2

; 144  : 	}

  00016	c2 04 00	 ret	 4
?GetPacketSize@CBuffer2@@UAEKPAE@Z ENDP			; CBuffer2::GetPacketSize
_TEXT	ENDS
EXTRN	__imp__htons@4:NEAR
; Function compile flags: /Ogty
;	COMDAT ?SetHeader@CBuffer2@@UAEXK@Z
_TEXT	SEGMENT
_uDataSize$ = 8						; size = 4
?SetHeader@CBuffer2@@UAEXK@Z PROC NEAR			; CBuffer2::SetHeader, COMDAT
; _this$ = ecx

; 148  : //		*(UNALIGNED WORD*)m_pTail	= (WORD)(uDataSize + 2);
; 149  : //		m_pTail += sizeof(WORD);
; 150  : 		*(UNALIGNED WORD*)m_pTail	= htons( (WORD)(uDataSize + 2) );

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _uDataSize$[esp-4]
  00004	56		 push	 esi
  00005	83 c0 02	 add	 eax, 2
  00008	50		 push	 eax
  00009	8b f1		 mov	 esi, ecx
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__htons@4
  00011	8b 8e 18 20 00
	00		 mov	 ecx, DWORD PTR [esi+8216]
  00017	66 89 01	 mov	 WORD PTR [ecx], ax

; 151  : 		m_pTail += sizeof(WORD);

  0001a	83 86 18 20 00
	00 02		 add	 DWORD PTR [esi+8216], 2
  00021	5e		 pop	 esi

; 152  : 	}

  00022	c2 04 00	 ret	 4
?SetHeader@CBuffer2@@UAEXK@Z ENDP			; CBuffer2::SetHeader
_TEXT	ENDS
PUBLIC	?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z	; CBufferQueue::AddTail
; Function compile flags: /Ogty
;	COMDAT ?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z
_TEXT	SEGMENT
_pBuffer$ = 8						; size = 4
?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z PROC NEAR	; CBufferQueue::AddTail, COMDAT
; _this$ = ecx

; 224  : {	

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f1		 mov	 esi, ecx

; 225  : 	CMclAutoLock	Lock( m_cs );

  00004	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00007	57		 push	 edi
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 226  : //	Add it to the active list	
; 227  : 	if( !m_pHead )

  0000e	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00011	85 c0		 test	 eax, eax
  00013	8b 44 24 0c	 mov	 eax, DWORD PTR _pBuffer$[esp+4]
  00017	75 03		 jne	 SHORT $L227368

; 228  : 		m_pHead		= pBuffer;

  00019	89 46 04	 mov	 DWORD PTR [esi+4], eax
$L227368:

; 229  : 	if( m_pTail )

  0001c	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0001f	85 c9		 test	 ecx, ecx
  00021	74 06		 je	 SHORT $L227369

; 230  : 		m_pTail->pNext	= pBuffer;

  00023	89 81 1c 20 00
	00		 mov	 DWORD PTR [ecx+8220], eax
$L227369:

; 231  : 	pBuffer->pPrevious	= m_pTail;

  00029	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0002c	89 88 20 20 00
	00		 mov	 DWORD PTR [eax+8224], ecx

; 232  : 	pBuffer->pNext	= NULL;

  00032	c7 80 1c 20 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+8220], 0

; 233  : 	m_pTail		= pBuffer;
; 234  : 	m_uCount++;

  0003c	8b 4e 0c	 mov	 ecx, DWORD PTR [esi+12]
  0003f	41		 inc	 ecx

; 235  : }

  00040	57		 push	 edi
  00041	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00044	89 4e 0c	 mov	 DWORD PTR [esi+12], ecx
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	c2 04 00	 ret	 4
?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z ENDP		; CBufferQueue::AddTail
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCBuffer@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBuffer@@UAEPAXI@Z PROC NEAR			; CBuffer::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 86 0c 20 00
	00		 mov	 eax, DWORD PTR [esi+8204]
  00009	8b 8e 10 20 00
	00		 mov	 ecx, DWORD PTR [esi+8208]
  0000f	2b c8		 sub	 ecx, eax
  00011	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  00017	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBuffer@@6B@
  0001d	7e 0c		 jle	 SHORT $L228928
  0001f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A ; CBuffer::m_pHeapMng
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?Free@CHeapMng@@QAEXPAX@Z ; CHeapMng::Free
$L228928:
  0002b	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  00030	74 09		 je	 SHORT $L228930
  00032	56		 push	 esi
  00033	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00038	83 c4 04	 add	 esp, 4
$L228930:
  0003b	8b c6		 mov	 eax, esi
  0003d	5e		 pop	 esi
  0003e	c2 04 00	 ret	 4
??_GCBuffer@@UAEPAXI@Z ENDP				; CBuffer::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	??_7CBufferQueue@@6B@				; CBufferQueue::`vftable'
PUBLIC	??_GCBufferQueue@@UAEPAXI@Z			; CBufferQueue::`scalar deleting destructor'
PUBLIC	??0CBufferQueue@@QAE@XZ				; CBufferQueue::CBufferQueue
EXTRN	??_ECBufferQueue@@UAEPAXI@Z:NEAR		; CBufferQueue::`vector deleting destructor'
;	COMDAT ??_7CBufferQueue@@6B@
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
CONST	SEGMENT
??_7CBufferQueue@@6B@ DD FLAT:??_ECBufferQueue@@UAEPAXI@Z ; CBufferQueue::`vftable'
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
CONST	ENDS
;	COMDAT ??0CBufferQueue@@QAE@XZ
_TEXT	SEGMENT
??0CBufferQueue@@QAE@XZ PROC NEAR			; CBufferQueue::CBufferQueue, COMDAT
; _this$ = ecx

; 72   : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8d 46 14	 lea	 eax, DWORD PTR [esi+20]
  00006	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBufferQueue@@6B@
  0000c	50		 push	 eax
  0000d	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET FLAT:??_7CMclCritSec@@6B@
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 73   : 	m_uCount	= 0;

  0001a	33 c0		 xor	 eax, eax
  0001c	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 74   : 	m_pHead		= m_pTail	= NULL;

  0001f	89 46 08	 mov	 DWORD PTR [esi+8], eax
  00022	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 75   : #ifdef __CRC
; 76   : 	m_pcrc	= NULL;
; 77   : 	m_dwWriteHeaderSize		= HEADERSIZE5;
; 78   : #endif	// __CRC
; 79   : 
; 80   : #ifdef __PROTOCOL0910
; 81   : 	m_pdwProtocolId		= NULL;
; 82   : #endif	// __PROTOCOL0910
; 83   : 
; 84   : #ifdef __PACKET_REPLAY_W
; 85   : 	m_nPacket	= 0;
; 86   : #endif	// __PACKET_REPLAY_W
; 87   : }

  00025	8b c6		 mov	 eax, esi
  00027	5e		 pop	 esi
  00028	c3		 ret	 0
??0CBufferQueue@@QAE@XZ ENDP				; CBufferQueue::CBufferQueue
_TEXT	ENDS
PUBLIC	?Clear@CBufferQueue@@QAEXH@Z			; CBufferQueue::Clear
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T228977 DD	0ffffffffH
	DD	FLAT:$L228946
$T228971 DD	019930520H
	DD	01H
	DD	FLAT:$T228977
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
xdata$x	ENDS
;	COMDAT ?Clear@CBufferQueue@@QAEXH@Z
_TEXT	SEGMENT
tv129 = -20						; size = 4
_Lock$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_bDelete$ = 8						; size = 4
?Clear@CBufferQueue@@QAEXH@Z PROC NEAR			; CBufferQueue::Clear, COMDAT
; _this$ = ecx

; 95   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$?Clear@CBufferQueue@@QAEXH@Z
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	83 ec 08	 sub	 esp, 8
  00018	53		 push	 ebx
  00019	55		 push	 ebp
  0001a	8b d9		 mov	 ebx, ecx

; 96   : 	CMclAutoLock	Lock( m_cs );

  0001c	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  0001f	57		 push	 edi
  00020	8d 78 04	 lea	 edi, DWORD PTR [eax+4]
  00023	57		 push	 edi
  00024	89 44 24 14	 mov	 DWORD PTR _Lock$[esp+36], eax
  00028	89 7c 24 10	 mov	 DWORD PTR tv129[esp+36], edi
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 97   : 
; 98   : 	if( bDelete )

  00032	8b 44 24 24	 mov	 eax, DWORD PTR _bDelete$[esp+28]
  00036	33 ed		 xor	 ebp, ebp
  00038	3b c5		 cmp	 eax, ebp
  0003a	89 6c 24 1c	 mov	 DWORD PTR __$EHRec$[esp+40], ebp
  0003e	74 48		 je	 SHORT $L227440
  00040	56		 push	 esi

; 99   : 	{
; 100  : 		CBuffer* pBuffer	= GetHead(), *ptrtmp;

  00041	8b 73 04	 mov	 esi, DWORD PTR [ebx+4]

; 101  : 
; 102  : 		INIT_LOOP;
; 103  : 		while( pBuffer )

  00044	3b f5		 cmp	 esi, ebp
  00046	74 3f		 je	 SHORT $L228976
  00048	eb 06 8d 9b 00
	00 00 00	 npad	 8
$L227439:

; 104  : 		{
; 105  : 			VERIFY_LOOP( __FILE__, __LINE__ );

  00050	45		 inc	 ebp
  00051	81 fd e8 03 00
	00		 cmp	 ebp, 1000		; 000003e8H
  00057	75 14		 jne	 SHORT $L227441
  00059	6a 69		 push	 105			; 00000069H
  0005b	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@
  00060	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  00065	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
$L227441:

; 106  : 
; 107  : 			ptrtmp	= pBuffer->pNext;
; 108  : 			SAFE_DELETE( pBuffer );

  0006d	8b 06		 mov	 eax, DWORD PTR [esi]
  0006f	8b be 1c 20 00
	00		 mov	 edi, DWORD PTR [esi+8220]
  00075	6a 01		 push	 1
  00077	8b ce		 mov	 ecx, esi
  00079	ff 10		 call	 DWORD PTR [eax]
  0007b	85 ff		 test	 edi, edi

; 109  : 			pBuffer	= ptrtmp;

  0007d	8b f7		 mov	 esi, edi
  0007f	75 cf		 jne	 SHORT $L227439
  00081	8b 7c 24 10	 mov	 edi, DWORD PTR tv129[esp+36]
  00085	33 ed		 xor	 ebp, ebp
$L228976:
  00087	5e		 pop	 esi
$L227440:

; 110  : 		}
; 111  : 	}
; 112  : 	m_uCount	= 0;
; 113  : 	m_pHead	= m_pTail	= NULL;
; 114  : }

  00088	57		 push	 edi
  00089	89 6b 0c	 mov	 DWORD PTR [ebx+12], ebp
  0008c	89 6b 08	 mov	 DWORD PTR [ebx+8], ebp
  0008f	89 6b 04	 mov	 DWORD PTR [ebx+4], ebp
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4
  00098	8b 4c 24 14	 mov	 ecx, DWORD PTR __$EHRec$[esp+32]
  0009c	5f		 pop	 edi
  0009d	5d		 pop	 ebp
  0009e	5b		 pop	 ebx
  0009f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000a6	83 c4 14	 add	 esp, 20			; 00000014H
  000a9	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L228946:
  00000	8d 4d f0	 lea	 ecx, DWORD PTR _Lock$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1CMclAutoLock@@QAE@XZ	; CMclAutoLock::~CMclAutoLock
__ehhandler$?Clear@CBufferQueue@@QAEXH@Z:
  00008	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T228971
  0000d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?Clear@CBufferQueue@@QAEXH@Z ENDP			; CBufferQueue::Clear
PUBLIC	?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\include\buffer.h
xdata$x	SEGMENT
$T229003 DD	0ffffffffH
	DD	FLAT:$L228992
	DD	0ffffffffH
	DD	FLAT:$L228993
$T228999 DD	019930520H
	DD	02H
	DD	FLAT:$T229003
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
xdata$x	ENDS
;	COMDAT ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T228989 = 8						; size = 4
$T228985 = 8						; size = 4
_type$ = 8						; size = 4
_uBufSize$ = 12						; size = 4
?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z PROC NEAR ; CBufferFactory::CreateBuffer, COMDAT
; _this$ = ecx

; 280  : {

  00000	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list

; 281  : 	CBuffer* pBuffer = NULL;
; 282  : 	switch( type )

  00006	8b 4c 24 04	 mov	 ecx, DWORD PTR _type$[esp-4]
  0000a	6a ff		 push	 -1
  0000c	68 00 00 00 00	 push	 __ehhandler$?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z
  00011	50		 push	 eax
  00012	33 c0		 xor	 eax, eax
  00014	2b c8		 sub	 ecx, eax
  00016	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  0001d	56		 push	 esi
  0001e	74 56		 je	 SHORT $L227520
  00020	49		 dec	 ecx
  00021	0f 85 8c 00 00
	00		 jne	 $L227517

; 286  : 		break;
; 287  : 	case BUFFER_TYPE_2BYTE:
; 288  : 		pBuffer = new CBuffer2( uBufSize );

  00027	68 28 20 00 00	 push	 8232			; 00002028H
  0002c	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00031	8b f0		 mov	 esi, eax
  00033	83 c4 04	 add	 esp, 4
  00036	89 74 24 14	 mov	 DWORD PTR $T228989[esp+12], esi
  0003a	85 f6		 test	 esi, esi
  0003c	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 1
  00044	74 6b		 je	 SHORT $L228986
  00046	8b 44 24 18	 mov	 eax, DWORD PTR _uBufSize$[esp+12]
  0004a	50		 push	 eax
  0004b	8b ce		 mov	 ecx, esi
  0004d	e8 00 00 00 00	 call	 ??0CBuffer@@QAE@K@Z	; CBuffer::CBuffer
  00052	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBuffer2@@6B@
  00058	c7 86 24 20 00
	00 02 00 00 00	 mov	 DWORD PTR [esi+8228], 2
  00062	8b c6		 mov	 eax, esi

; 289  : 		break;
; 290  : 	default:
; 291  : 		ASSERT(0);
; 292  : 		break;
; 293  : 	}
; 294  : 	return pBuffer;
; 295  : }

  00064	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  00068	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0006f	5e		 pop	 esi
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	c2 08 00	 ret	 8
$L227520:

; 283  : 	{
; 284  : 	case BUFFER_TYPE_5BYTE:
; 285  : 		pBuffer = new CBuffer( uBufSize );

  00076	68 28 20 00 00	 push	 8232			; 00002028H
  0007b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00080	83 c4 04	 add	 esp, 4
  00083	89 44 24 14	 mov	 DWORD PTR $T228985[esp+12], eax
  00087	85 c0		 test	 eax, eax
  00089	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  00091	74 1e		 je	 SHORT $L228986
  00093	8b 4c 24 18	 mov	 ecx, DWORD PTR _uBufSize$[esp+12]
  00097	51		 push	 ecx
  00098	8b c8		 mov	 ecx, eax
  0009a	e8 00 00 00 00	 call	 ??0CBuffer@@QAE@K@Z	; CBuffer::CBuffer

; 289  : 		break;
; 290  : 	default:
; 291  : 		ASSERT(0);
; 292  : 		break;
; 293  : 	}
; 294  : 	return pBuffer;
; 295  : }

  0009f	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  000a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000aa	5e		 pop	 esi
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	c2 08 00	 ret	 8
$L228986:

; 283  : 	{
; 284  : 	case BUFFER_TYPE_5BYTE:
; 285  : 		pBuffer = new CBuffer( uBufSize );

  000b1	33 c0		 xor	 eax, eax
$L227517:

; 289  : 		break;
; 290  : 	default:
; 291  : 		ASSERT(0);
; 292  : 		break;
; 293  : 	}
; 294  : 	return pBuffer;
; 295  : }

  000b3	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  000be	5e		 pop	 esi
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c2	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L228993:
  00000	8b 45 04	 mov	 eax, DWORD PTR $T228989[ebp-4]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
$L228992:
  0000b	8b 45 04	 mov	 eax, DWORD PTR $T228985[ebp-4]
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00014	59		 pop	 ecx
  00015	c3		 ret	 0
__ehhandler$?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z:
  00016	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T228999
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ENDP ; CBufferFactory::CreateBuffer
PUBLIC	??1CBuffer2@@UAE@XZ				; CBuffer2::~CBuffer2
; Function compile flags: /Ogty
;	COMDAT ??_GCBuffer2@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBuffer2@@UAEPAXI@Z PROC NEAR			; CBuffer2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CBuffer2@@UAE@XZ
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L229009
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L229009:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCBuffer2@@UAEPAXI@Z ENDP				; CBuffer2::`scalar deleting destructor'
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??1CBuffer2@@UAE@XZ
_TEXT	SEGMENT
??1CBuffer2@@UAE@XZ PROC NEAR				; CBuffer2::~CBuffer2, COMDAT
; _this$ = ecx
  00000	8b 81 0c 20 00
	00		 mov	 eax, DWORD PTR [ecx+8204]
  00006	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:??_7CBuffer@@6B@
  0000c	8b 89 10 20 00
	00		 mov	 ecx, DWORD PTR [ecx+8208]
  00012	2b c8		 sub	 ecx, eax
  00014	81 f9 00 20 00
	00		 cmp	 ecx, 8192		; 00002000H
  0001a	7e 0c		 jle	 SHORT $L229016
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A ; CBuffer::m_pHeapMng
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ?Free@CHeapMng@@QAEXPAX@Z ; CHeapMng::Free
$L229016:
  00028	c3		 ret	 0
??1CBuffer2@@UAE@XZ ENDP				; CBuffer2::~CBuffer2
_TEXT	ENDS
PUBLIC	??1CBufferQueue@@UAE@XZ				; CBufferQueue::~CBufferQueue
;	COMDAT xdata$x
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\mcl\include\cmclcritsec.h
xdata$x	SEGMENT
$T229029 DD	0ffffffffH
	DD	FLAT:$L229021
$T229027 DD	019930520H
	DD	01H
	DD	FLAT:$T229029
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
; File c:\documents and settings\test\mes documents\source\virtuos_v17\build\program\_network\net\src\buffer.cpp
xdata$x	ENDS
;	COMDAT ??1CBufferQueue@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1CBufferQueue@@UAE@XZ PROC NEAR			; CBufferQueue::~CBufferQueue, COMDAT
; _this$ = ecx

; 90   : {

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$??1CBufferQueue@@UAE@XZ
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	56		 push	 esi
  00017	8b f1		 mov	 esi, ecx
  00019	89 74 24 04	 mov	 DWORD PTR _this$[esp+20], esi
  0001d	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:??_7CBufferQueue@@6B@

; 91   : 	Clear( TRUE );	// 2004/01/19

  00023	6a 01		 push	 1
  00025	c7 44 24 14 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+32], 0
  0002d	e8 00 00 00 00	 call	 ?Clear@CBufferQueue@@QAEXH@Z ; CBufferQueue::Clear

; 92   : }

  00032	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], OFFSET FLAT:??_7CMclCritSec@@6B@
  00039	83 c6 14	 add	 esi, 20			; 00000014H
  0003c	56		 push	 esi
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteCriticalSection@4
  00043	8b 4c 24 08	 mov	 ecx, DWORD PTR __$EHRec$[esp+20]
  00047	5e		 pop	 esi
  00048	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0004f	83 c4 10	 add	 esp, 16			; 00000010H
  00052	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229021:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 10	 add	 ecx, 16			; 00000010H
  00006	e9 00 00 00 00	 jmp	 ??1CMclCritSec@@UAE@XZ	; CMclCritSec::~CMclCritSec
__ehhandler$??1CBufferQueue@@UAE@XZ:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229027
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
??1CBufferQueue@@UAE@XZ ENDP				; CBufferQueue::~CBufferQueue
PUBLIC	?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ; CBufferQueue::AddData
; Function compile flags: /Ogty
;	COMDAT ?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z
_TEXT	SEGMENT
___loop$ = -12						; size = 4
_cb$ = -12						; size = 4
tv229 = -8						; size = 4
_this$ = -4						; size = 4
_lpData$ = 8						; size = 4
_uDataSize$ = 12					; size = 4
_type$ = 16						; size = 4
?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z PROC NEAR ; CBufferQueue::AddData, COMDAT
; _this$ = ecx

; 117  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 118  : //	CMclAutoLock	Lock( m_cs );
; 119  : 	u_long	uRemnant	= uDataSize;
; 120  : 	CBuffer* pBuffer	= GetTail();

  00008	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]

; 121  : 	LPBYTE ptr;
; 122  : 	int cb;
; 123  : 
; 124  : 	if( pBuffer )

  0000b	85 db		 test	 ebx, ebx
  0000d	57		 push	 edi
  0000e	89 74 24 18	 mov	 DWORD PTR _this$[esp+28], esi
  00012	74 24		 je	 SHORT $L227458

; 125  : 	{
; 126  : 		cb	= pBuffer->GetWritableBufferSize();

  00014	8b 83 10 20 00
	00		 mov	 eax, DWORD PTR [ebx+8208]
  0001a	8b 93 18 20 00
	00		 mov	 edx, DWORD PTR [ebx+8216]

; 127  : #ifdef __CRC
; 128  : 		if( cb < (int)( m_dwWriteHeaderSize ) )
; 129  : #else	// __CRC
; 130  : 		if( cb < (int)( pBuffer->GetHeaderLength() ) )

  00020	8b 8b 24 20 00
	00		 mov	 ecx, DWORD PTR [ebx+8228]
  00026	2b c2		 sub	 eax, edx
  00028	3b c1		 cmp	 eax, ecx
  0002a	7d 2c		 jge	 SHORT $L227461

; 131  : #endif	// __CRC
; 132  : 		{
; 133  : 			pBuffer	= CBufferFactory::GetInstance().CreateBuffer( type );

  0002c	8b 4c 24 28	 mov	 ecx, DWORD PTR _type$[esp+24]
  00030	68 00 20 00 00	 push	 8192			; 00002000H
  00035	51		 push	 ecx

; 134  : 			AddTail( pBuffer );
; 135  : 		}
; 136  : 	}
; 137  : 	else

  00036	eb 0a		 jmp	 SHORT $L229060
$L227458:

; 138  : 	{
; 139  : 		pBuffer	= CBufferFactory::GetInstance().CreateBuffer( type );

  00038	8b 54 24 28	 mov	 edx, DWORD PTR _type$[esp+24]
  0003c	68 00 20 00 00	 push	 8192			; 00002000H
  00041	52		 push	 edx
$L229060:
  00042	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00047	8b c8		 mov	 ecx, eax
  00049	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer
  0004e	8b d8		 mov	 ebx, eax

; 140  : 		AddTail( pBuffer );

  00050	8b ce		 mov	 ecx, esi
  00052	53		 push	 ebx
  00053	e8 00 00 00 00	 call	 ?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z ; CBufferQueue::AddTail
$L227461:

; 141  : 	}
; 142  : 	
; 143  : 	ptr	= pBuffer->GetWritableBuffer( &cb );

  00058	8b b3 18 20 00
	00		 mov	 esi, DWORD PTR [ebx+8216]
  0005e	8b ab 10 20 00
	00		 mov	 ebp, DWORD PTR [ebx+8208]

; 144  : 
; 145  : #ifdef __CRC
; 146  : //	header
; 147  : 	*ptr	= HEADERMARK;
; 148  : 
; 149  : 	if( m_pcrc )
; 150  : 	{
; 151  : 		BYTE digest[sizeof(DWORD)];
; 152  : 		m_pcrc->Restart();
; 153  : 		m_pcrc->Update( (const byte*)( &uDataSize ), sizeof(u_long) );
; 154  : 		m_pcrc->Final( digest );
; 155  : 		int nOffset	= sizeof(char);
; 156  : #ifdef __PACKET_REPLAY_W
; 157  : 		*(UNALIGNED int*)( ptr + nOffset )		= ++m_nPacket;
; 158  : 		nOffset	+= sizeof(int);
; 159  : 		*(UNALIGNED DWORD*)( ptr + nOffset )	= ~( *(UNALIGNED DWORD*)digest ^ ( *m_pdwProtocolId + m_nPacket ) );
; 160  : #else	// __PACKET_REPLAY_W
; 161  : 		*(UNALIGNED DWORD*)( ptr + nOffset )	= ~( *(UNALIGNED DWORD*)digest ^ *m_pdwProtocolId );
; 162  : #endif	// __PACKET_REPLAY_W
; 163  : 		nOffset	+= sizeof(DWORD);
; 164  : 		*(UNALIGNED DWORD*)( ptr + nOffset )	= (DWORD)uDataSize;
; 165  : 		nOffset	+= sizeof(DWORD);
; 166  : 		m_pcrc->Restart();
; 167  : 		m_pcrc->Update( (const byte*)( lpData ), (u_int)uDataSize );
; 168  : 		m_pcrc->Final( digest );
; 169  : #ifdef __PACKET_REPLAY_W
; 170  : 		*(UNALIGNED DWORD*)( ptr + nOffset )	= ~( *(UNALIGNED DWORD*)digest ^ ( *m_pdwProtocolId + m_nPacket ) );
; 171  : #else	// __PACKET_REPLAY_W
; 172  : 		*(UNALIGNED DWORD*)( ptr + nOffset )	= ~( *(UNALIGNED DWORD*)digest ^ *m_pdwProtocolId );
; 173  : #endif	// __PACKET_REPLAY_W
; 174  : 		nOffset	+= sizeof(DWORD);
; 175  : 	}
; 176  : 	else
; 177  : 	{
; 178  : 		*(UNALIGNED DWORD*)&ptr[1]	= (DWORD)uDataSize;
; 179  : 	}
; 180  : //	data
; 181  : 	cb	= ( cb-m_dwWriteHeaderSize < uRemnant? cb-m_dwWriteHeaderSize: uRemnant );
; 182  : 	ASSERT( &ptr[m_dwWriteHeaderSize] + cb <= pBuffer->m_lpBufMax );
; 183  : 	memcpy( (void*)&ptr[m_dwWriteHeaderSize], lpData, cb );
; 184  : 	pBuffer->m_pTail	= ptr + m_dwWriteHeaderSize + cb;
; 185  : 
; 186  : #else	// __CRC
; 187  : 
; 188  : //	header
; 189  : 	pBuffer->SetHeader( uDataSize );	

  00064	8b 03		 mov	 eax, DWORD PTR [ebx]
  00066	2b ee		 sub	 ebp, esi
  00068	8b 74 24 24	 mov	 esi, DWORD PTR _uDataSize$[esp+24]
  0006c	56		 push	 esi
  0006d	8b cb		 mov	 ecx, ebx
  0006f	ff 50 08	 call	 DWORD PTR [eax+8]

; 190  : 	cb -= pBuffer->GetHeaderLength();

  00072	2b ab 24 20 00
	00		 sub	 ebp, DWORD PTR [ebx+8228]

; 191  : 
; 192  : 	if( cb >= (int)( uRemnant ) )

  00078	3b ee		 cmp	 ebp, esi
  0007a	89 6c 24 10	 mov	 DWORD PTR _cb$[esp+28], ebp
  0007e	7c 06		 jl	 SHORT $L227463

; 193  : 		cb = uRemnant;

  00080	89 74 24 10	 mov	 DWORD PTR _cb$[esp+28], esi
  00084	8b ee		 mov	 ebp, esi
$L227463:

; 194  : 
; 195  : 	memcpy( pBuffer->m_pTail, lpData, cb );

  00086	8b bb 18 20 00
	00		 mov	 edi, DWORD PTR [ebx+8216]
  0008c	8b 74 24 20	 mov	 esi, DWORD PTR _lpData$[esp+24]

; 196  : 	pBuffer->m_pTail +=  cb;
; 197  : 
; 198  : #endif	// __CRC
; 199  : 
; 200  : 	uRemnant	-= cb;

  00090	8b 44 24 10	 mov	 eax, DWORD PTR _cb$[esp+28]
  00094	8b cd		 mov	 ecx, ebp
  00096	8b d1		 mov	 edx, ecx
  00098	c1 e9 02	 shr	 ecx, 2
  0009b	f3 a5		 rep movsd
  0009d	8b ca		 mov	 ecx, edx
  0009f	83 e1 03	 and	 ecx, 3
  000a2	f3 a4		 rep movsb
  000a4	8b 8b 18 20 00
	00		 mov	 ecx, DWORD PTR [ebx+8216]
  000aa	03 cd		 add	 ecx, ebp
  000ac	8b 6c 24 24	 mov	 ebp, DWORD PTR _uDataSize$[esp+24]
  000b0	2b e8		 sub	 ebp, eax
  000b2	89 8b 18 20 00
	00		 mov	 DWORD PTR [ebx+8216], ecx

; 201  : 
; 202  : 	INIT_LOOP;

  000b8	b8 00 00 00 00	 mov	 eax, 0

; 203  : 	while( uRemnant > 0 )

  000bd	0f 84 98 00 00
	00		 je	 $L227467
  000c3	eb 0b		 jmp	 SHORT $L227466
$L229059:
  000c5	8b 44 24 10	 mov	 eax, DWORD PTR ___loop$[esp+28]
  000c9	8d a4 24 00 00
	00 00		 npad	 7
$L227466:

; 204  : 	{
; 205  : 		VERIFY_LOOP( __FILE__, __LINE__ );

  000d0	40		 inc	 eax
  000d1	3d e8 03 00 00	 cmp	 eax, 1000		; 000003e8H
  000d6	89 44 24 10	 mov	 DWORD PTR ___loop$[esp+28], eax
  000da	75 17		 jne	 SHORT $L227468
  000dc	68 cd 00 00 00	 push	 205			; 000000cdH
  000e1	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_0GI@FCHJFKGE@?2Documents?5and?5Settings?2test?2Mes@
  000e6	68 00 00 00 00	 push	 OFFSET FLAT:??_C@_05DIALNFFA@?$CFs?5?$CFd?$AA@
  000eb	e8 00 00 00 00	 call	 ?Error@@YAPBDPBDZZ	; Error
  000f0	83 c4 0c	 add	 esp, 12			; 0000000cH
$L227468:

; 206  : 
; 207  : 		pBuffer	= CBufferFactory::GetInstance().CreateBuffer( type );

  000f3	8b 44 24 28	 mov	 eax, DWORD PTR _type$[esp+24]
  000f7	68 00 20 00 00	 push	 8192			; 00002000H
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?GetInstance@CBufferFactory@@SAAAV1@XZ ; CBufferFactory::GetInstance
  00102	8b c8		 mov	 ecx, eax
  00104	e8 00 00 00 00	 call	 ?CreateBuffer@CBufferFactory@@QAEPAVCBuffer@@W4BUFFER_TYPE@@K@Z ; CBufferFactory::CreateBuffer

; 208  : 		ptr	= pBuffer->GetWritableBuffer( &cb );

  00109	8b b8 18 20 00
	00		 mov	 edi, DWORD PTR [eax+8216]
  0010f	8b 98 10 20 00
	00		 mov	 ebx, DWORD PTR [eax+8208]
  00115	2b df		 sub	 ebx, edi

; 209  : 		cb	= ( cb < (int)( uRemnant ) ? cb: uRemnant );

  00117	3b dd		 cmp	 ebx, ebp
  00119	89 7c 24 14	 mov	 DWORD PTR tv229[esp+28], edi
  0011d	7c 02		 jl	 SHORT $L229036
  0011f	8b dd		 mov	 ebx, ebp
$L229036:

; 210  : 		
; 211  : 		memcpy( (void*)ptr, &lpData[uDataSize - uRemnant], cb );

  00121	8b 74 24 20	 mov	 esi, DWORD PTR _lpData$[esp+24]
  00125	8b 54 24 24	 mov	 edx, DWORD PTR _uDataSize$[esp+24]
  00129	2b f5		 sub	 esi, ebp
  0012b	03 f2		 add	 esi, edx
  0012d	8b cb		 mov	 ecx, ebx
  0012f	8b d1		 mov	 edx, ecx
  00131	c1 e9 02	 shr	 ecx, 2
  00134	f3 a5		 rep movsd
  00136	8b ca		 mov	 ecx, edx
  00138	83 e1 03	 and	 ecx, 3
  0013b	f3 a4		 rep movsb

; 212  : 		pBuffer->m_pTail	= ptr + cb;

  0013d	8b 4c 24 14	 mov	 ecx, DWORD PTR tv229[esp+28]
  00141	03 cb		 add	 ecx, ebx
  00143	89 88 18 20 00
	00		 mov	 DWORD PTR [eax+8216], ecx

; 213  : 		AddTail( pBuffer );

  00149	8b 4c 24 18	 mov	 ecx, DWORD PTR _this$[esp+28]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 ?AddTail@CBufferQueue@@QAEXPAVCBuffer@@@Z ; CBufferQueue::AddTail

; 214  : 		uRemnant	-= cb;

  00153	2b eb		 sub	 ebp, ebx
  00155	0f 85 6a ff ff
	ff		 jne	 $L229059
$L227467:
  0015b	5f		 pop	 edi
  0015c	5e		 pop	 esi
  0015d	5d		 pop	 ebp
  0015e	5b		 pop	 ebx

; 215  : 	}
; 216  : }

  0015f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00162	c2 0c 00	 ret	 12			; 0000000cH
?AddData@CBufferQueue@@QAEXPAEKW4BUFFER_TYPE@@@Z ENDP	; CBufferQueue::AddData
; Function compile flags: /Ogty
_TEXT	ENDS
;	COMDAT ??_GCBufferQueue@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GCBufferQueue@@UAEPAXI@Z PROC NEAR			; CBufferQueue::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	e8 00 00 00 00	 call	 ??1CBufferQueue@@UAE@XZ	; CBufferQueue::~CBufferQueue
  00008	f6 44 24 08 01	 test	 BYTE PTR ___flags$[esp], 1
  0000d	74 09		 je	 SHORT $L229064
  0000f	56		 push	 esi
  00010	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00015	83 c4 04	 add	 esp, 4
$L229064:
  00018	8b c6		 mov	 eax, esi
  0001a	5e		 pop	 esi
  0001b	c2 04 00	 ret	 4
??_GCBufferQueue@@UAEPAXI@Z ENDP			; CBufferQueue::`scalar deleting destructor'
_TEXT	ENDS
EXTRN	??0CHeapMng@@QAE@XZ:NEAR			; CHeapMng::CHeapMng
CRT$XCU	SEGMENT
_$S2	DD	FLAT:_$E1
CRT$XCU	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T229077 DD	0ffffffffH
	DD	FLAT:$L229072
$T229074 DD	019930520H
	DD	01H
	DD	FLAT:$T229077
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogty
xdata$x	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
$T229069 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_$E1	PROC NEAR					; COMDAT

; 34   : CHeapMng*	CBuffer::m_pHeapMng		= new CHeapMng;

  00000	6a ff		 push	 -1
  00002	68 00 00 00 00	 push	 __ehhandler$_$E1
  00007	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:__except_list
  0000d	50		 push	 eax
  0000e	64 89 25 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, esp
  00015	51		 push	 ecx
  00016	6a 08		 push	 8
  00018	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0001d	83 c4 04	 add	 esp, 4
  00020	89 04 24	 mov	 DWORD PTR $T229069[esp+16], eax
  00023	85 c0		 test	 eax, eax
  00025	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR __$EHRec$[esp+24], 0
  0002d	74 1b		 je	 SHORT $L229070
  0002f	8b c8		 mov	 ecx, eax
  00031	e8 00 00 00 00	 call	 ??0CHeapMng@@QAE@XZ	; CHeapMng::CHeapMng
  00036	a3 00 00 00 00	 mov	 DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A, eax ; CBuffer::m_pHeapMng
  0003b	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0003f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  00046	83 c4 10	 add	 esp, 16			; 00000010H
  00049	c3		 ret	 0
$L229070:
  0004a	8b 4c 24 04	 mov	 ecx, DWORD PTR __$EHRec$[esp+16]
  0004e	33 c0		 xor	 eax, eax
  00050	a3 00 00 00 00	 mov	 DWORD PTR ?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A, eax ; CBuffer::m_pHeapMng
  00055	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:__except_list, ecx
  0005c	83 c4 10	 add	 esp, 16			; 00000010H
  0005f	c3		 ret	 0
text$yc	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L229072:
  00000	8b 45 f0	 mov	 eax, DWORD PTR $T229069[ebp]
  00003	50		 push	 eax
  00004	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00009	59		 pop	 ecx
  0000a	c3		 ret	 0
__ehhandler$_$E1:
  0000b	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:$T229074
  00010	e9 00 00 00 00	 jmp	 ___CxxFrameHandler
text$x	ENDS
_$E1	ENDP
PUBLIC	?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A		; CBuffer::m_pHeapMng
_BSS	SEGMENT
?m_pHeapMng@CBuffer@@2PAVCHeapMng@@A DD 01H DUP (?)	; CBuffer::m_pHeapMng
_BSS	ENDS
END
